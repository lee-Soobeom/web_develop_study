### DBMS

## 개념

- DBMS(Database Management System)는 웹 개발 뿐만 아니라 서버(혹은 서비스 제공자 등)가 클라이언트( 혹은 일반적인 사용자, 고객군)에게 서비스를 제공하는데 있어, 소실되면 안 되고
  유지, 기억해야하는 내용들을 SQL(언어)을 통해 쉽게 처리하기 위해 사용하는 체계이다.
- SQL(Structured Query Language)은 DBMS가 가지는 구조 및 데이터를 통제하기 위해 사용하는 언어이다.

## 규칙

- SQL 키워드는 대문자로 작성하는 것이 권장되나, 소문자로 작성하여도 무방하다. 단, 섞어서 작성하지 않도록 한다.
- 모든 구성요소(스키마, 테이블, 열, 사용자 이름 등)의 이름은 소문자 스네이크 케이스로 명명한다.
- 모든 구성요소의 이름을 언급할 때에는 백틱(```)으로 감싼다.
- 문자열 리터럴은 홀따옴표(`'`)로 감싼다.
- 하나의 쿼리가 끝나는 경우 쿼리의 끝에 세미콜론(`;`)을 작성한다. 세미콜론을 작성하기 전까지는 개행이 이루어져도 하나의 쿼리인 것으로 간주한다.

## 주석

- 주석(Comment)은 쿼리 실행에 영향을 미치지 않고 간단한 메모를 남기기 위해 사용한다.
- 한 줄 주석: 한 줄 주석은 샾(`#`)및 대쉬 두 개 (`--`)를 작성하여 사용할 수 있다.
- 여러 줄 주석: `/*`로 시작하여 `*/`로 끝낸다.

## 스키마

- 스키마(`Schema`)는 서로 관련있는 테이블을 묶어내기 위해 사용한다.
- 주로 하나의 서비스(플랫폼)에 대한 데이터를 가지는 테이블들을 묶어내기 위해 하나의 스키마를 만들어 사용한다.
- `SCHEMA`라는 키워드는 `DATABASE`라는 키워드와 치환하여 사용하여도 된다.
- 실제 데이터를 직접 가지지 않는 단순한 껍데기이다.
- 명명법: 소문자 스네이크 케이스, 단수.

### 생성하기

- 스키마를 생성하기 위해 아래 쿼리를 실행한다.

>       CREATE SCHEMA `이름`;
> - 이미 존재하는 스키마의 이름을 사용할 수 없음에 유의한다.

### 조회하기

- 존재하는 스키마의 목록을 조회하기 위해 아래 쿼리를 실행한다.

>       SHOW SCHEMA;

### 수정하기

- 스키마의 이름을 변경하는 것은 불가능하다.
- 결과적으로 동일한 결론에 도달하기 위해, 새로운 이름을 가지는 스키마를 생성하고, 이전 스키마에 있는 모든 테이블들을 새로운 스키마로 옮긴 뒤, 이전 스키마를 삭제하는 방식으로 진행하여야한다.

### 삭제하기

- 존재하는 스키마를 삭제하기 위해 아래 쿼리를 실행한다.
- 스키마를 삭제하면 이가 가지고 있는 테이블 및 테이블의 레코드가 모두 삭제되고 되돌릴 수 없음으로 유의한다.

>       DROP SCHEMA `이름`;

## 테이블

- 테이블(Table)은 실제 데이터(레코드)를 담기위해 존재한다.
- 테이블은 독립적으로 존재할 수 없고 반드시 스키마에 소속되어 있어야 한다.
- 명명법: 소문자 스네이크 메이스, 복수형

### 생성하기

- 테이블을 생성하기 위해 아래 쿼리를 실행한다.

>       CREATE TABLE `소속 스키마 이름`.`테이블 이름`
>       (
>           [열 구조, ...],
>           [제약 조건 구조, ...]
>       );

### 조회하기

- 특정 스키마에 소속되어있는 테이블의 목록을 조회하기 위해 아래 쿼리를 실행한다.

>       SHOW TABLE IN `소속 스키마 이름`;

- 특정 테이블이 가지고 있는 열의 구조를 조회하기 위해 아래 쿼리를 실행한다.

>       DESC `스키마 이름`, `테이블 이름`;   
>
>       DESCRIBE `스키마 이름`, `테이블 이름`;

### 수정하기

#### 이름 및 소속 스키마 변경하기

#### 열 추가하기

#### 열 이름 변경하기

#### 열 구조 수정하기

#### 열 삭제하기

### 삭제하기

- 테이블을 삭제하기 위해 아래 쿼리를 실행한다. 테이블을 삭제하면 이가 가지고 있는 레코드가 모두 삭제되고 되돌릴 수 없음으로 유의한다.

>       DROP TABLE `스키마 이름`, `테이블 이름`;

## 열

- 열(Column)은 테이블에 존재하는 레코드가 가지는 데이터릐 타입을 정하기 위해 사용한다.
- 명명법: 소문자 스네이크 케이스, 단수형
- 열 구조는 아래와 같다.

>       `열 이름` [데이터 타입] [NULL|NOT NULL]? [DEFAULT]? []?,
>       `열 이름` [데이터 타입]
>
>       `name`   VARCHAR(50) NOT NULL,
>       `value`  INT         NULL DEFAULT 0
>
> - `NULL`: 해당 열의 값이 비어있을 수 있다는 의미이다. 생략시 기본값.
> - `NOT NULL`: 해당 열의 값이 비어있을 수 없다는 의미이다.
> - `DEFAULT x`: 레코드 삽입시 해당 열의 값을 명시하지 않을 경우 사용할 기본 값을 `x`로 설정한다. 생략시 `x`는 `NULL`이다.
> - `AUTO_INCREMENT`: 데이터 타입이 숫자인(인덱싱 되는) 열에 사용할수 있고, `1`부터 시작하여 레코드가 삽입될 때마다 `1`씩 증가하게 하기 위해 사용한다. 단, 모종의 사유로 레코드 삽입이
    실패하거나 레코드가 삭제되어도 테이블의 메타 데이터에서 카운팅되는 값을 기준으로 함으로, 이 값이 재정렬되거나 감소하지 않는다. 이에 해당 값은 절대로 해당 테이블이 가지고 있는 레코드의 개수로 인식되어서는
    안되다.

## 데이터 타입

- 모든 정수형과 `DECIMAL`을 제외한 실수형 타입 뒤에 `UNSIGNED`키워드를 붙여 음수부 크기 만큼 양수를 추가적으로 사용할 수 있다. 가열 `TINYINT UNSIGNED`타입의 범위는 `0`부터 `
  255`까지이다.

### 정수형

- `TINYINT`: (1 Byte) `-128` 부터 `127`까지의 정수
- `SMALLINT`: (2 Bytes) `-32,768`부터 `32,767`까지의 정수
- `MEDIUMINT`: (3 Bytes) `-8,388,608`부터 `8,388,607`까지의 정수
- `INT`: (4 Bytes) `-2,147,483,648`부터 `2,147,483,647`까지의 정수
- `BIGINT`: (8 Bytes) `-9,223,372,036,854,775,808`부터 `9,223,372,036,854,775,807`까지의 정수

### 실수형

- `FLOAT`: (4 Bytes) `-3.402823466E+38`부터 `3.402823466E+38`까지의 부동 소수. 값을 저장하는 방식 때문에 오류(오차)가 발생할 수 있어 유의해야한다. (정수 길이에 따라
  최대 소수점 7번째 자리까지 정확성 보장.)
- `DOUBLE`: (8 Bytes) `-1.797693134862315157E+308`부터 `1.797693134862315157E+308`까지의 부동 소수. 값을 저장하는 방식 때문에 오류(오차)가 발생할 수
  있어 유의해야한다. (정수 길이에 따라 최대 소수점 15번째 자리까지 정확성 보장.)
- `DECIMAL(t, p)`: (가변 용량, `t` Bytes) 전체 길이가 `t`, 소수부 길이가 `p`인 고정 소수. 차지하는 용량이 큰 대신 값이 유실되지 않는다. 정수부와 소수부는 할당된 길이를 초과할 수
  없고 남는 공간을 다른 부분에 빌려줄 수 없다.

### 문자형

- `VARCHAR(n)`: (`4n` Bytes, `n`은 최대 `65,535`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `TINYTEXT(N)`: (`4n` Bytes, `n`은 최대 `255`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `TEXT(N)`: (`4n` Bytes, `n`은 최대 `65,535`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `MEDIUMTEXT(n)`: (`4n` Bytes, `n`은 최대 `16,777,215`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `LONGTEXT(n)`: (`4n` Bytes, `n`은 최대 `4,294,967,295`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.

>       id  writer      title         content
>       INT VARCHAR(50) VARCHAR(1000) VARCHAR(65000) = 66054 > 65535 : 테이블 안만들어진다.
> - 주의: 하나의 테이블이 가지는 열 구조 중에, 데이터 타입이 인라인(In-row)인 데이터 타입의 (데이터) 크기의 합이 65,535를 초과할 수 없음
> - TEXT는 off-page 이기 때문에 사용가능하다. 다른 파일로 저장해두고 참조하는 형식. 따라서 서버에서 바로 가져와서 사용해야하는 경우 맞지않다. (content 같은 경우 제목 눌러서 들어갔을 때
    보여주면 됨)
>
> - VARCHAR(1) : 1 Byte ~ 4 Bytes => UTF8MB4
> - 0~9 a~z(라틴) 일부 특수문자(기본) : 1 Byte
> - 일부 확장 라틴 : 2 Bytes
> - CJK(한일중 국어) : 3 Bytes
> - 이모지 : 4 Bytes

### 논리형

- `BOOLEAN`: (1 Byte) 참(`TRUE`)과 거짓(`FALSE`)을 가질 수 있다. 실제로는 `TINYINT(1)` 타입이고, 참은 `1`로, 거짓은 `0`으로 처리된다.

### 날짜및 시간

- `DATE`: 날짜(년, 월, 일)를 가질 수 있다.
- `TIME(n)`:시간(시, 분, 초)을 가질 수 있다. `n`은 마이크로초의 길이를 의미하며, 생략시 `0`이고 최대 길이는 `6`이다.
- `DATETIME(n)`: 날짜와 시간을 가질 수 있다. `n`은 마이크로초의 길이를 의미하며, 생략시 `0`이고 최대 길이는 `6`이다.

### 기타

- `TINYBLOB(n)`: (`n` Bytes, `n`은 최대 `255`) 이진 데이터를 담기 위해 사용한다.
- `BLOB(n)`: (`n` Bytes, `n`은 최대 `65,535`) 이진 데이터를 담기 위해 사용한다.
- `MEDIUMBLOB(n)`: (`n` Bytes, `n`은 최대 `16,777,215`) 이진 데이터를 담기 위해 사용한다.
- `LONGBLOB(n)`: (`n` Bytes, `n`은 최대 `4,294,967,295`) 이진 데이터를 담기 위해 사용한다.
- 이진 데이터: **첨부파일** 집어넣을 때 데이터







