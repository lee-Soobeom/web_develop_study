### DBMS

## 개념

- DBMS(Database Management System)는 웹 개발 뿐만 아니라 서버(혹은 서비스 제공자 등)가 클라이언트( 혹은 일반적인 사용자, 고객군)에게 서비스를 제공하는데 있어, 소실되면 안 되고
  유지, 기억해야하는 내용들을 SQL(언어)을 통해 쉽게 처리하기 위해 사용하는 체계이다.
- SQL(Structured Query Language)은 DBMS가 가지는 구조 및 데이터를 통제하기 위해 사용하는 언어이다.

## 규칙

- SQL 키워드는 대문자로 작성하는 것이 권장되나, 소문자로 작성하여도 무방하다. 단, 섞어서 작성하지 않도록 한다.
- 모든 구성요소(스키마, 테이블, 열, 사용자 이름 등)의 이름은 소문자 스네이크 케이스로 명명한다.
- 모든 구성요소의 이름을 언급할 때에는 백틱(```)으로 감싼다.
- 문자열 리터럴은 홀따옴표(`'`)로 감싼다.
- 하나의 쿼리가 끝나는 경우 쿼리의 끝에 세미콜론(`;`)을 작성한다. 세미콜론을 작성하기 전까지는 개행이 이루어져도 하나의 쿼리인 것으로 간주한다.

## 주석

- 주석(Comment)은 쿼리 실행에 영향을 미치지 않고 간단한 메모를 남기기 위해 사용한다.
- 한 줄 주석: 한 줄 주석은 샾(`#`)및 대쉬 두 개 (`--`)를 작성하여 사용할 수 있다.
- 여러 줄 주석: `/*`로 시작하여 `*/`로 끝낸다.

## 스키마

- 스키마(`Schema`)는 서로 관련있는 테이블을 묶어내기 위해 사용한다.
- 주로 하나의 서비스(플랫폼)에 대한 데이터를 가지는 테이블들을 묶어내기 위해 하나의 스키마를 만들어 사용한다.
- `SCHEMA`라는 키워드는 `DATABASE`라는 키워드와 치환하여 사용하여도 된다.
- 실제 데이터를 직접 가지지 않는 단순한 껍데기이다.
- 명명법: 소문자 스네이크 케이스, 단수.

### 생성하기

- 스키마를 생성하기 위해 아래 쿼리를 실행한다.

>       CREATE SCHEMA `이름`;
> - 이미 존재하는 스키마의 이름을 사용할 수 없음에 유의한다.

### 조회하기

- 존재하는 스키마의 목록을 조회하기 위해 아래 쿼리를 실행한다.

>       SHOW SCHEMA;

### 수정하기

- 스키마의 이름을 변경하는 것은 불가능하다.
- 결과적으로 동일한 결론에 도달하기 위해, 새로운 이름을 가지는 스키마를 생성하고, 이전 스키마에 있는 모든 테이블들을 새로운 스키마로 옮긴 뒤, 이전 스키마를 삭제하는 방식으로 진행하여야한다.

### 삭제하기

- 존재하는 스키마를 삭제하기 위해 아래 쿼리를 실행한다.
- 스키마를 삭제하면 이가 가지고 있는 테이블 및 테이블의 레코드가 모두 삭제되고 되돌릴 수 없음으로 유의한다.

>       DROP SCHEMA `이름`;

## 테이블

- 테이블(Table)은 실제 데이터(레코드)를 담기위해 존재한다.
- 테이블은 독립적으로 존재할 수 없고 반드시 스키마에 소속되어 있어야 한다.
- 명명법: 소문자 스네이크 메이스, 복수형

### 생성하기

- 테이블을 생성하기 위해 아래 쿼리를 실행한다.

>       CREATE TABLES `소속 스키마 이름`.`테이블 이름`
>       (
>           [열 구조, ...],
>           [제약 조건 구조, ...]
>       );

### 조회하기

- 특정 스키마에 소속되어있는 테이블의 목록을 조회하기 위해 아래 쿼리를 실행한다.

>       SHOW TABLES IN `소속 스키마 이름`;

- 특정 테이블이 가지고 있는 열의 구조를 조회하기 위해 아래 쿼리를 실행한다.

>       DESC `스키마 이름`, `테이블 이름`;   
>
>       DESCRIBE `스키마 이름`, `테이블 이름`;

### 수정하기

#### 이름 및 소속 스키마 변경하기

- 존재하는 테이블의 이름을 변경하거나, 소속 스키마를 변경하고자 할때 아래 쿼리를 실행한다.

>       ALTER TABLE `기존 스키마 이름`.`기존 테이블 이름` RENAME `새로운 스키마 이름`.`새로운 테이블 이름`;
>
> - 소속 스키마 만 바꾸는 경우
> - 테이블 이름 만 바꾸는 경우
> - 스키마, 테이블 둘 다 바꾸는 경우
>
> 
>       ALTER TABLE `기존 스키마`.`기존 테이블 이름` CHANGE COLUMN `기존 열 이름` `새로운 열 이름` [열 구조];
>   
> - RENAME + MODIFY = CHANGE

#### 열 추가하기

- 존재하는 테이블에 열을 추가하기 위해 아래 쿼리를 실행한다.

>       ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조];
>       ALTER TABEL `study1103`.`people` ADD COLUMN `adress` VARCHAR(100) NULL;
> - 별도의 명시가 없다면 추가되는 열은 테이블의 가장 마지막 자리에 추가된다.
> - 추가하려는 열을 특정 열 뒤에 추가하려면 아래와 같이 `AFTER` 키워드를 활용한다.
>
>       ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조] AFTER `대상 열 이름`;
> - `AFTER`의 반대되는 개념인 `BEFORE` 키워드는 존재하지 않으며 가장 앞 자리에 열을 추가하기 위해 `FIRST` 키워드를 활용한다.
>
>       ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조] FIRST;

#### 열 이름 변경하기

- 존재하는 열의 이름을 변경하기 위해 아래 쿼리를 실행한다.

>       ALTER TABLE `스키마 이름`.`테이블 이름` RENAME COLUMN `기존 열 이름` TO `새로운 열 이름`;

#### 열 구조 수정하기

- 존재하는 열의 구조를 수정하기 위해 아래 쿼리를 실행한다.

>       ALTER TABLE `스키마 이름`.`테이블 이름` MODIFY COLUMN [열 구조];
> - 열 구조 수정과 동시에 `AFTER` 및 `FIRST` 키워드를 사용하여 위치 또한 옮길 수 있다. 단 위치만 옮긴다 하더라도 기존의 열 구조를 다시 작성해야함에 유의한다.
> - NOT NULL 과 같은 옵션들 빠지지 않게 수정한다.

#### 열 삭제하기

- 존재하는 열을 삭제하기 위해 아래 쿼리를 실행한다. 열을 삭제하면 이에 해당하는 로케드들이 가지고 있는 데이터가 삭제되고 되돌릴 수 없음으로 유의한다.

>        ALTER TABLE `스키마 이름`.`테이블 이름` DROP COLUMN `열 이름`;

### 삭제하기

- 테이블을 삭제하기 위해 아래 쿼리를 실행한다. 테이블을 삭제하면 이가 가지고 있는 레코드가 모두 삭제되고 되돌릴 수 없음으로 유의한다.

>       DROP TABLE `스키마 이름`.`테이블 이름`;

## 열

- 열(Column)은 테이블에 존재하는 레코드가 가지는 데이터릐 타입을 정하기 위해 사용한다.
- 명명법: 소문자 스네이크 케이스, 단수형
- 열 구조는 아래와 같다.

>       `열 이름` [데이터 타입] [NULL|NOT NULL]? [DEFAULT]? []?,
>       `열 이름` [데이터 타입]
>
>       `name`   VARCHAR(50) NOT NULL,
>       `value`  INT         NULL DEFAULT 0
>
> - `NULL`: 해당 열의 값이 비어있을 수 있다는 의미이다. 생략시 기본값.
> - `NOT NULL`: 해당 열의 값이 비어있을 수 없다는 의미이다.
> - `DEFAULT x`: 레코드 삽입시 해당 열의 값을 명시하지 않을 경우 사용할 기본 값을 `x`로 설정한다. 생략시 `x`는 `NULL`이다.
> - `AUTO_INCREMENT`: 데이터 타입이 숫자인(인덱싱 되는) 열에 사용할수 있고, `1`부터 시작하여 레코드가 삽입될 때마다 `1`씩 증가하게 하기 위해 사용한다. 단, 모종의 사유로 레코드 삽입이
    실패하거나 레코드가 삭제되어도 테이블의 메타 데이터에서 카운팅되는 값을 기준으로 함으로, 이 값이 재정렬되거나 감소하지 않는다. 이에 해당 값은 절대로 해당 테이블이 가지고 있는 레코드의 개수로 인식되어서는
    안되다.

## 데이터 타입

- 모든 정수형과 `DECIMAL`을 제외한 실수형 타입 뒤에 `UNSIGNED`키워드를 붙여 음수부 크기 만큼 양수를 추가적으로 사용할 수 있다. 가열 `TINYINT UNSIGNED`타입의 범위는 `0`부터 `
  255`까지이다.

### 정수형

- `TINYINT`: (1 Byte) `-128` 부터 `127`까지의 정수
- `SMALLINT`: (2 Bytes) `-32,768`부터 `32,767`까지의 정수
- `MEDIUMINT`: (3 Bytes) `-8,388,608`부터 `8,388,607`까지의 정수
- `INT`: (4 Bytes) `-2,147,483,648`부터 `2,147,483,647`까지의 정수
- `BIGINT`: (8 Bytes) `-9,223,372,036,854,775,808`부터 `9,223,372,036,854,775,807`까지의 정수

### 실수형

- `FLOAT`: (4 Bytes) `-3.402823466E+38`부터 `3.402823466E+38`까지의 부동 소수. 값을 저장하는 방식 때문에 오류(오차)가 발생할 수 있어 유의해야한다. (정수 길이에 따라
  최대 소수점 7번째 자리까지 정확성 보장.)
- `DOUBLE`: (8 Bytes) `-1.797693134862315157E+308`부터 `1.797693134862315157E+308`까지의 부동 소수. 값을 저장하는 방식 때문에 오류(오차)가 발생할 수
  있어 유의해야한다. (정수 길이에 따라 최대 소수점 15번째 자리까지 정확성 보장.)
- `DECIMAL(t, p)`: (가변 용량, `t` Bytes) 전체 길이가 `t`, 소수부 길이가 `p`인 고정 소수. 차지하는 용량이 큰 대신 값이 유실되지 않는다. 정수부와 소수부는 할당된 길이를 초과할 수
  없고 남는 공간을 다른 부분에 빌려줄 수 없다.

### 문자형

- `VARCHAR(n)`: (`4n` Bytes, `n`은 최대 `65,535`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `TINYTEXT(N)`: (`4n` Bytes, `n`은 최대 `255`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `TEXT(N)`: (`4n` Bytes, `n`은 최대 `65,535`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `MEDIUMTEXT(n)`: (`4n` Bytes, `n`은 최대 `16,777,215`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.
- `LONGTEXT(n)`: (`4n` Bytes, `n`은 최대 `4,294,967,295`) 문자를 담기위해 사용한다. 최대 `n`개의 문자를 담을 수 있다.

>       id  writer      title         content
>       INT VARCHAR(50) VARCHAR(1000) VARCHAR(65000) = 66054 > 65535 : 테이블 안만들어진다.
> - 주의: 하나의 테이블이 가지는 열 구조 중에, 데이터 타입이 인라인(In-row)인 데이터 타입의 (데이터) 크기의 합이 65,535를 초과할 수 없음
> - TEXT는 off-page 이기 때문에 사용가능하다. 다른 파일로 저장해두고 참조하는 형식. 따라서 서버에서 바로 가져와서 사용해야하는 경우 맞지않다. (content 같은 경우 제목 눌러서 들어갔을 때
    보여주면 됨)
>
> - VARCHAR(1) : 1 Byte ~ 4 Bytes => UTF8MB4
> - 0~9 a~z(라틴) 일부 특수문자(기본) : 1 Byte
> - 일부 확장 라틴 : 2 Bytes
> - CJK(한일중 국어) : 3 Bytes
> - 이모지 : 4 Bytes

### 논리형

- `BOOLEAN`: (1 Byte) 참(`TRUE`)과 거짓(`FALSE`)을 가질 수 있다. 실제로는 `TINYINT(1)` 타입이고, 참은 `1`로, 거짓은 `0`으로 처리된다.

### 날짜및 시간

- `DATE`: 날짜(년, 월, 일)를 가질 수 있다.
- `TIME(n)`:시간(시, 분, 초)을 가질 수 있다. `n`은 마이크로초의 길이를 의미하며, 생략시 `0`이고 최대 길이는 `6`이다.
- `DATETIME(n)`: 날짜와 시간을 가질 수 있다. `n`은 마이크로초의 길이를 의미하며, 생략시 `0`이고 최대 길이는 `6`이다.

### 기타

- `TINYBLOB(n)`: (`n` Bytes, `n`은 최대 `255`) 이진 데이터를 담기 위해 사용한다.
- `BLOB(n)`: (`n` Bytes, `n`은 최대 `65,535`) 이진 데이터를 담기 위해 사용한다.
- `MEDIUMBLOB(n)`: (`n` Bytes, `n`은 최대 `16,777,215`) 이진 데이터를 담기 위해 사용한다.
- `LONGBLOB(n)`: (`n` Bytes, `n`은 최대 `4,294,967,295`) 이진 데이터를 담기 위해 사용한다.
- 이진 데이터: **첨부파일** 집어넣을 때 데이터

### 레코드

#### 삽입하기

- 테이블에 레코드를 삽입하기 위해 아래 쿼리를 실행한다.

>       INSERT INTO `스키마 이름`.`테이블 이름` ([열 이름, ...])
>       VALUES ([값, ...]);
>
> - 위 쿼리에서 명시한 열의 순서와 값의 순서는 반드시 일치해야 한다.
> - 명시하는 열의 순서는 테이블이 실제로 가지고 있는 열의 순서와 반드시 일치할 필요는 없다.
> - 명시되지 않은 열의 값에 대해서는 해당 열의 기본값(`DEFAULT`)을 사용한다. 그러므로 `NOT NULL`이며 `DEFAULT`가 없는 열을 반드시 명시되어야만 한다. (`NOT NULL` 이며
    `DEFAULT`가 없는 열은 실질적으로 `NOT NULL DEFAULT NULL`이고, 레코드 삽입시 해당 열을 명시하지 않는다면 누락된 기본값인 `NULL`을 `NOT NULL`인 열에 삽입하려 하는
    것이기 때문에 레코드가 삽입되지 않는다.)
> - 열 이름을 명시하지 않을 경우 테이블이 가지고 있는 모든 열을 순서대로 적은 것과 같은 효과를 가진다.

- 하나의 쿼리로 여러개의 레코드를 한번에 삽입하기 위해 아래 쿼리를 실행한다.

>       INSERT INTO `스키마 이름`.`테이블 이름` ([열 이름, ...])
>       VALUES ([값, ...]),
>              ([값, ...]),
>              ([값, ...]), ...;
>
>       // 어려개(많이) 삽입해야 한다면 하나의 쿼리로 실행하는 것이 좋다.

#### 선택하기

- 테이블이 가지고 있는 레코드를 조회하기 위해 아래 쿼리를 실행한다.

>       SELECT [*|열,...|리터럴,...]
>       [FROM `스키마 이름1`.`테이블 이름`]?
>       [JOIN...]?
>       [WHRER [조건]]?
>       [ORDER BY [기준 열] [ASC|DESC]?]?
>
> - `*`: 테이블이 가지고 있는 모든 열을 의미한다.
> - `WHERE`: 명시된 조건에 참(`TRUE`)인 레코드만 선택한다.
> - `ORDER BY`: 선택 결과를 정렬하기 위해 사용한다. 정렬에 사용할 값을 가지고 있는 열을 명시한다. 선택 결과를 정렬하지 않는 경우, 기본 키(Primary key)가 있는 테이블의 경우 이를 기준으로
    오름 차순 정렬하고, 그렇지 않은 경우 삽입된 순서대로, 별도로 정렬하지 않는다.
> - `ASC`: 오름차순 정렬. 생략시 기본값 .
> - `DESC`: 내림 차순 정렬.
> - 옵션 값들의 순서는 지켜서 사용해야한다. WHERE > ORDER BY

#### 조인(JOIN)

- 조인(Join) 기능은 현재 조회하고 있는 테이블이 **가지고있는 데이터**를 활용하여 다른 테이블에 있는 데이터를 함께 선택하고자할 때 사용한다.
- 조인의 구조는 아래와 같다.

>       [LEFT|RIGHT|INNER] JOIN `스키마 이름`.`테이블 이름` AS `별명` ON [조건]
> 
> - 조인 대상이 되는 테이블이 자기는 레코드 중 조건에 부합하는 레코드를 모두 가져온다.
> - `LEFT`: `SELECT`의 `FROM`대상이 되는 테이블이 가지는 데이터를 기준으로 선택한다.
> - `RIGHT`: `JOIN` 대상이 되는 테이블이 가지는 데이터를 기준으로 선택한다.
> - `INNER`: `SELECT`의 `FROM`과 `JOIN` 대상이 되는 두 테이블이 가지는 데이터의 교집합을 기준으로 선택한다.
> - `LEFT` 및 `RIGHT`의 경우 조건에 부합하는 데이터가 없을 경우 `null`로 대체한다.
> - SELECT 대상 테이블이 가지고 있지 않은 데이터를 다른 테이블에서 가지고 오기 위해 사용한다.
> - 테이블 나누는 이유
>   - 하나의 엔티티가 여러개의 값을 가질 수 있는 경우
>   - 테이블의 원자성
>   - 무결성을 지키기 위해서


#### 수정하기

- 레코드가 가지고 있는 값을 수정하기 위해 아래 쿼리를 실행한다.

>       UPDATE `스키마 이름`.`테이블 이름`
>       SET [열 이름] = [새로운 값],...;
>
> - 위 쿼리는 조건 없이 모든 레코드의 값을 수정하는 쿼리임으로 일반적으로 사용하지 않는다.
> - 주로 아래와 같이 `WHERE` 키워드를 사용하여 수정하고자 하는 레코드를 특정한다.
>
>
>       UPDATE `스키마 이름`.`테이블 이름`
>       SET [열 이름] = [새로운 값],...
>       WHERE [조건]
>       LIMIT [개수];

#### 삭제하기

- 레코드 삭제하기 위해 아래 쿼리를 실행한다.

>       DELETE
>       FROM `스키마 이름`.`테이블 이름`;
>
> - 위 쿼리는 조건 없이 모든 레코드를 삭제하는 쿼리임으로 일반적으로 사용하지 않는다.
> - 주로 아래와 같이 `WHERE` 키워드를 사용하여 삭제하고자 하는 레코드를 특정한다.
>
>
>       DELETE
>       FROM `스키마 이름`.`테이블 이름`
>       WHERE [조건]
>       LIMIT [개수];

## 연산자

### 사칙 연산자

- `+`: `a + b` 꼴에서 `a`와 `b`의 합이다.
- `-`: `a - b` 꼴에서 `a`와 `b`의 차이다.
- `*`: `a * b` 꼴에서 `a`와 `b`의 곱이다.
- `/`: `a / b` 꼴에서 `a`와 `b`의 나눈 몫이다.
- `%` 혹은 `MOD`: `a % b` 혹은 `a MOD b` 꼴에서 `a`를 `b`로 나눈 나머지이다.

### 비교 연산자

- `=`: `a = b` 꼴에서 `a` 와 `b`가 같은가의 여부이다. 단, 기본 설정 상에서 두 피연산자의 대소문자를 구분하지 않음에 유의한다.
- BINARY: 대소문자 가려준다.
- `!=` 혹은 `<>`: `a != b` 혹은 `a <> b` 꼴에서 `a`와 `b`가 다른가의 여부이다.
- `>`: `a > b` 꼴에서 `a` 가 `b`보다 큰가의 여부이다.
- `<`: `a < b` 꼴에서 `a` 가 `b`보다 작은가의 여부이다.
- `>=`: `a >= b` 꼴에서 `a` 가 `b`보다 큰거나 같은가의 여부이다.
- `<=`: `a <= b` 꼴에서 `a` 가 `b`보다 작거나 같은가의 여부이다.

### 논리 연산자

- `&&` 혹은 `AND`: `a && b` 혹은 `a AND b` 꼴에서 논리 `a`와 `b` 가 모두 참(`TRUE`)인가의 여부이다.
- `||` 혹은 `OR`: `a || b` 혹은 `a OR b` 꼴에서 논리 `a` 와 `b`중 하나가 참(`TRUE`)인가의 여부이다.
- `!` 혹은 `NOT`: `!a` 혹은 `NOT a` 꼴에서 논리 `a`를 부정(반전)한다.

### 기타 연산자
- `IN`: `a IN (b,...)`꼴에서 `a`가 후행하는 값의 나열에 포함되는가의 여부이다.
  - `NOT IN`: `a NOT IN (b,...)`
- `BETWEEN AND`: `a BETWEEN b AND c` 꼴에서 `a`가 `b` 이상이고 `c` 이하인가의 여부이다. `a >= b AND a <= c`와 같다.
  - `NOT BETWEEN AND`: `a NOT BETWEEN b AND c`
- `IS NULL`: `a IS NULL` 꼴에서 `a`가 `NULL` 인가의 여부이다.
  - 어떠한 값이 `NULL`인지 검사하기 위해 비교연산(`=`, `!=` 혹은 `<>`)하지 않음에 유의한다.
- `LIKE`: `a LIKE b`꼴에서 `a`가 `b`패턴에 부합하는가의 여부이다.
  - 패턴은 문자열로 작성한다.
  - 패턴에서 `_`는 1개의 아무 문자이다.
  - 패턴에서 `%`는 0개 이상의 아무 문자이다.
  - 패턴에서 리터럴 `%` 는 `\%`로, 리터럴 `_`는 `\_`로, 리터럴 `\`는 `\\`로 이스케이프(Escape)하여 체크한다.
- `REGEXP`: `a REGEXP b`꼴에서 `a`가 정규표현식 `b`를 만속하는가의 여부이다.
  - `NOT REGEXP`: `a NOT REGEXP b` ('010-1234-5678' '^010-\\d{4}-\\d{4}$' )

## 함수

### 수학 함수
- `ABS(x)`: `x`의 절댓값을 반환한다.
- `MOD(x, y)`: `x MOD y` 의 결과를 반환한다.
- `POW(x, y)`: `x`의 `y` 제곱을 반환한다.
- `SQRT(x)`: `x`의 제곱근을 반환한다.
- `CEIL(x)`:`x`를 정수부까지 내림하여 반환한다.
- `ROUND`
  - `ROUND(x)`: `x`를 정수부까지 반올림하여 반환한다.
  - `ROUND(x, y)`: `x`를 소수점 `y`자리까지 반올림하여 반환한다.
- `TRUNCATE(x, y)`: `x`가 가진 `y`자리 미만의 소수점을 버리고 반환한다. `TRUNCATE(x)` 꼴의 함수가 없음에 유의한다.
- `RAND()`: `0` 이상 `1`미만의 무작위 실수를 반환한다.

### 논리 함수
- `IF(c, t, f)`: 조건 `c`가 참일 때 `t`를, 거짓일 때 `f`를 반환한다.
- `IFNULL(x, a)`: `x`가 `NULL`이라면 `a`를, 아니라면 `x`를 반환한다.

### 문자 함수
- `LEGNTH(x)`: 문자열 `x`의 바이트 크기를 반환한다.
- `CHAR_LENGTH(x)`: 문자열 `x`의 문자 개수를 반환한다.
- `CONCAT(x, ...)`: 한 개 이상의 인자 `x`를 이어붙인 문자열을 반환한다. (문자열 합치기(`+`)를 지원 안해주기 때문에 사용한다.)
- `CONCAT_WS(d, x, ...)`: 한 개 이상의 인자 `x`를 `d`로 이어 붙인 문자열을 반환한다. (CONCAT_WS('-', '2025', '11', '05');)
- `LCASE(x)` 혹은 `LOWER(x)`: 문자열 `x`가 가지는 라틴 문자를 소문자화하여 반환한다.
- `UCASE(x)` 혹은 `UPPER(x)`: 문자열 `x`가 가지는 라틴 문자를 대문자화하여 반환한다.
- `MID(x, y, z)` 혹은 `SUBSTR(x, y, z)` 혹은 `SUBSTRING(x, y, z)`: 문자열 `x`가 가지는 문자 중 `y`번째 문자를 포함, 후행하는 `z`개의 문자열을 반환한다.
  - 단, 첫번째 인자(`x`)인 문자열에서 문자의 순번은 `1`번부터 시작함에 유의한다.
  - 선택할 문자의 개수를 의미하는 세번째 인자(`z`)를 생략할 경우 끝까지 선택한다.
  - JS substring()과 사용법(인덱스)이 다르다. 
- `LEFT(x, y)`: 문자열 `x`의 선행 문자 `y`개를 반환한다.
- `RIGHT(x, y)`: 문자열 `x`의 후행 문자 `y`개를 반환한다.
- `REPEAT(x, y)`: 인자 `x`를 `y`번 반복한 문자열을 반환한다.
- `REPLACE(x, f, t)`: 문자열 `x`에서 `f`를 찾아 `t`로 치환하여 반환한다.
- `REVERSE(x)`: 문자열 `x`를 뒤집어서 반환한다.
- `TRIM(x)`: 문자열 `x`의 선/후행 공백을 제거하여 반환한다.
- `LTRIM(x)`: 문자열 `x`의 선행 공백을 제거하여 반환한다.
- `RTRIM(x)`: 문자열 `x`의 후행 공백을 제거하여 반환한다.

### 날짜 및 시간 함수

- `CURDATE()` 혹은 `CURRENT_DATE()`: 현재 날짜를 반환한다.
- `CURTIME(x)` 혹은 `CURRENT_TIME(x)`: 현재 시간을 반환한다. 여기서 `x`는 마이크로 초의 자리수를 의미하며 생략하면 결과값은 마이크로초를 포함하지 않는다. 최대값은 `6`이다. 단, 클라이언트의 접속 정보에 따라 마이크로초가 누락될 수 있음으로 유의한다.
- `CURRENT_TIMESTAMP(x)` 혹은 `NOW(x)` 혹은 `SYSDATE(x)`: 현재 날짜와 시간을 반환한다. 여기서 `x`는 마이크로 초의 자리수를 의미하며 생략하면 결과값은 마이크로초를 포함하지 않는다. 최대값은 `6`이다.
  - `CURRENT_TIMESTAMP` 와 `NOW`는 동일한 함수이다.
  - `CURRENT_TIMESTAMP` 와 `NOW`가 현재 일시를 반환하는 시점은 이를 포함하는 쿼리가 실행되는 시점이다.
  - `SYSDATE`가 현재 일시를 반환하는 시점은 이를 포함하는 쿼리가 아닌, 해당 함수가 호출되는 시점이다.
- `YEAR(x)`: 전달 받은 날짜 혹은 일시인 `x`의 년(年)을 반환한다.
- `MONTH(x)`: 전달 받은 날짜 혹은 일시인 `x`의 월(月)을 반환한다.
- `DAY(x)` 혹은 `DATEOFMONTH(x)` : 전달 받은 날짜 혹은 일시인 `x`의 일(日)을 반환한다.
- `HOUR(x)`: 전달 받은 날짜 혹은 일시인 `x`의 시(時)를 반환한다.
- `MINUTE(x)`: 전달 받은 날짜 혹은 일시인 `x`의 분(分)을 반환한다.
- `SECOND(x)`: 전달 받은 날짜 혹은 일시인 `x`의 초(秒)를 반환한다.
- `MICROSECOND(x)`: 전달 받은 날짜 혹은 일시인 `x`의 마이크로초를 반환한다.
- `DATE(x)`: 전달 받은 일시의 날짜를 반환한다.
- `TIME(x)`: 전달 받은 일시의 시간을 반환한다.
- `DAYOFWEEK(x)`: 전달 받은 날짜 혹은 일시 `x`의 요일을 숫자로 반환한다. 일요일부터 `1`로 시작하여 `1`씩 증가한다. 토요일은 `7`이다.
- `DAYOFYEAR(x)`: 전달 받은 날짜 혹은 일시 `x`가 당해의 몇 번째 날인가를 반환한다.
- `DATE_ADD(x, INTERVAL y z)`: 일시 `x`에 `z`주기인 `y`만큼을 더한다. 주기는 `YEAR`, `QUATER`, `MONTH`, `WEEK`, `DAY`, `HOUR`, `MINUTE`, `SECOND` 등을 사용할 수 있다. (DATE_ADD(NOW(), INTERVAL 1 YEAR) 지금으로 부터 1년뒤를 반환한다. y에 음수 사용해서 과거로 가능하다.)
- `DATE_SUB(x, INTERVAL y z)`: 일시 `x`에 `z`주기인 `y`만큼을 뺀다. 주기는 `YEAR`, `QUATER`, `MONTH`, `WEEK`, `DAY`, `HOUR`, `MINUTE`, `SECOND` 등을 사용할 수 있다.

### 통계 함수

- `COUNT(x)`: 선택되는 열 `x`의 개수를 반환한다.
- `AVG(x)`: 선택되는 열 `x`의 평균을 반환한다.
- `SUM(x)`: 선택되는 열 `x`의 합을 반환한다.
- `MIN(x)`: 선택되는 열 `x`가 가지는 값 중 가장 작은 값을 반환한다.
- `MAX(x)`: 선택되는 열 `x`가 가지는 값 중 가장 큰 값을 반환한다.
