# javascript

## js

* js(javascript)는 html 언어로 작성된 페이지에 이벤트 등 동작과 연산을 적용하기 위해 사용한다.

## 적용 방법

* js를 적용하는 방법은 몇 가지가 있는데 다음과 같다.

- 스크립트 태그를 활용한 인라인 코드 작성
    - html 문서에 있는 head 혹은 body 태그의 자식이 될 수 있도록 script 태그를 만들어 해당 태그의 내부 내용에 js 문법을 작성하는 방법을 의미한다.
    - html 문서 내에 html 문법과 js 문법이 공존하게 됨으로 코드를 찾기 힘들어지고 유지보수가 까다로워진다.

* 이벤트 기반 속성 활용

- 코드를 적용하고자하는 태그에 onclick, onmouseover 등과 같은 이벤트 기반의 속성을 부여하는 방법을 의미한다.
- html 문서 내에 html 문법과 js 문법이 공존하게 됨으로 원하는 코드를 찾기 힘들어지고 유지보수가 까다로워진다.

* 스크립트 태그를 활용한 외부 자바스크립트 파일 로드

- 아래와 같이 head 태그의 자식이 되도록 script 태그를 작성하여 html 파일 외부 에서 작성된 js 파일을 불러와 사용할 수 있다.

>       <script src="..."></script>
> - src : 불러올 js파일의 주소 및 경로
> - 외부 js 파일을 로드할 때에는 script 태그의 내부 내용을 비워둔다.

# 변수

- 변수(Variable)는 선언(Declaration) 및 값 초기화 (initialization) 이후 값이 변할 수 있는 것을 의미한다.
- 변수 선언시 별도의 자료형(타입)을 명시하지 않고, 명명법으로 카멜 케이스를 사용한다.
- 동일한 스코프(Scope)에서 사용중인 이름이나 약속된 키워드를 변수의 이름으로 사용할 수 없다.
- 변수 선언시 값을 부여(Assign) 하지 않으면 초기 값으로 undefined 가 할당된다.
- 변수는 let 키워드를 사용하여 다음과 같이 선언할 수 있다.
    - let[변수 이름];
        - 위 처럼 값 초기화 없이 변수를 선언할 경우 그 값은 undefined 로 초기화 된다.
        - 아래와 같은 방식으로 변수 선언과 값이 초기 값을 할당할 수 있다.
        - let[변수 이름]=[값];

# 상수

- 상수 (Constant)는 선언 및 초기화 이후 값이 변하지 않는 것을 의미한다.
- 상수 선언시 별도의 자료형(타입)을 명시하지 않고, 명명법으로 카멜 케이스를 사용한다.
- 동일한 스코프(Scope)에서 사용중인 이름이나 약속된 키워드를 상수의 이름으로 사용할 수 없다.
- 상수는 선언시 값을 반드시 부여하여야 한다.
- 상수 선언 및 값 초기화
    - const [상수 이름] = [값];

# 자료형

## 문자열

- 문자열 자료형을 표현하기 위해서 홀따옴표(') 혹은 쌍따옴표(")혹은 백틱(')을 사용한다.
- html과의 연동이 많은 자바스크립트 특성상 쌍따옴표를 많이 사용하는 html을 위하여 문자열 표현시 쌍따옴표를 많이 사용하지 않고 홀따옴표를 많이 사용한다.
- 백틱을 사용한 문자열 표현식(${})을 활용하여 문자열 사이에 외부 변수나 상수를 삽입하기 쉽고, 문자열 이어붙이기가 필요 없어 편리하다.

## 숫자

- 별도의 특수문자를 사용하지 않으며 자바스크립트의 숫자는 정수와 실수를 별도로 구분하지 않는다.

## 논리값

- 별도의 특수문자를 사용하지 않으며 참 ( true )과 거짓( false ) 으로 이루어져있다.

## 널리쉬(Nullish)

- 널리쉬(Nullish)는 null 과 undefined 를 포함한다.
- null 은 스택 영역의 null 라는 값을 가지고 있으며, 힙에는 빈 값을 참조하고 있다.
- undefined 는 스택 영역에 undefined 라는 값을 가지고 있으며, 힙에는 아무 값도 할당되어 있지 않다.
- null 과 undefined 는 유사하나 null 이 보다 의도적인 의미를 가진다.
- typeof null 은 object 임에 유의한다.
- typeof undefined 는 undefined 임에 유의한다.
- 어떠한 널리쉬 값에 대해 null 을 피연산자 동등( == )비교시 참( true )이 연산됨을 활용할 수 있다.
    - null == undefined 는 참( true )이다.

## 배열 (중요)

- 배열(Array)은 하나의 변수가 여러개의 값을 가질 수 있도록 하기위해 사용한다.
- 배열의 작성 형태는 JSON(javaScript Object Notation)Array의 형태와 유사하다.
- 배열은 대괄호 ([.])로 인자(들)를 감싸고, 각 인자는 쉼표(,)로 구분할 수 있다.
- 배열이 가지는 인자는 인덱스(순번)를 가지고, 해당 인덱스는 반드시 0 번부터 시작하며, 배열에 대괄호([,])인자 접근 연산자를 사용하여 각 인자에 접근할 수 있다.
    - let [변수 이름]=([인자,...]);

    * 위와 같이 대괄호([,])로 인자(들)를 감싸고, 각 인자는 쉼표(,)로 구분할 수 있다.
    * 가령, 'Apple' , 'Banana' , 'Orange' 라는 세 개의 문자열을 인자로 가지는 fruits 라는 배열은 아래와 같이 만들 수 있다.
        - let fruits = ['Apple', 'Banana', 'Orange'];
    * 배열기 가지는 인자는 인덱스를 가지는데, 첫번째 인자인 'Apple' 부터 0번이며, 순차적으로 1 씩 증가한다.
    * 아래와 같이 배열에 인자 접근 연산자([,])와 인덱스를 통해 각 인자에 접근할 수 있다.
        - console.log(fruits[0});//Apple
        - console.log(fruits[2});//Orange
    * 추가로, 인자 접근시 음수나 범위를 벗어난 값을 전달할 경우 undefined 가 된다.
        - console.log(fruits[-1]);//undefined
        - console.log(fruits[3]);//undefined

## 객체 속성

- length : 배열이 가지고 있는 인자의 개수이다.

## 객체 함수

- at(x) :호출 대상인 배열이 가지고 있는 인덱스가 x 인 인자를 반환한다.
- concat(x) :호출 대상인 배열과 인자인 배열 x 를 이어 붙인 새로운 배열을 반환한다.
- fill(...)
    - fill(x) :호출 대상인 배열이 가지고 있는 모든 인자를 x 로 대체한다.
    - fill(x, f) :호출 대상인 배열이 가지고 있는 인자들 중 인덱스가 f 이상인 인자를 x 로 대체한다.
    - fill(x, f, t) :호출 대상인 배열이 가지고 있는 인자들 중 인덱스가 f 이상이고 t 미만인 인자를 x 로 대체한다.
- includes(x) :호출 대상인 배열이 가지고 있는 인자 중 그 값이 x 와 일치하는 인자가 존재하는가의 여부를 반환한다.
- indexOf(x) :호출 대상인 배열이 가지고 있는 인자 중 그값이 x 와 일치하는 가장 빠른 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1을 반환한다.
- lastIndexOf(x) :호출 대상인 배열이 가지고 있는 인자 중 그 값이 x 와 일치하는 가장 마지막 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1 을 반환한다.
- join(...)
    - join() :호출 대상인 배열이 가지고 있는 인자를 쉼표(,)로 이어붙인 문자열을 반환한다.
    - join(x) :호출 대상인 배열이 가지고 있는 인자를 x 로 이어붙인 문자열을 반환한다.
- pop() :호출 대상인 배열이 가지고 있는 인자 중 마지막 인자를 배열에서 제거하고 이를 반환한다.
- push(x) :호출 대상인 배열의 끝에 새로운 인자 x 를 추가하고 배열의 길이( length) 를 반환한다.
- reverse() :호출 대상인 배열이 가지고 있는 인자의 순서를 뒤집는다.
- shift() : 호출 대상인 배열이 가지고 있는 인자 중 첫번째 인자를 배열에서 제거하고 이를 반환한다.
- slice(...) *본체와 다른 객체
    - slice() :호출 대상이 배열이 가지고 있는 인자를 그대로 가지는 배열을 복사하여 반환한다.
    - slice(f) :호출 대상인 배열이 가지고 있는 인자 중 인덱스가 f 이상인 인자를 가지는 배열을 복사하여 반환한다.
    - slice(f, t) :호출 대상인 배열이 가지고 있는 인자 중 인덱스가 f 이상, t 미만인 인자를 가지는 배열을 복사하여 반환한다.
- splice(...)
    - splice(i, d) :호출 대상이 되는 배열이 가지고 있는 인자 중 그 인덱스가 i 인것부터 d 개를 제거하여 반환한다.
    - splice(i, d, ...v) :호출 대상이 되는 배열이 가지고 있는 인자 중 그 인덱스가 i 인것 부터 d 개를 제거하여 제거된 인자를 배열로 반환하고, 가변인자 v 의 첫번째 인자의 인덱스가 i 가
      될 수 있도록 추가한다.
    - 예시
    ```
    let days = ['일','월','가','나','금','토']; 
    undefined
    days.splice(2,2,'화','수','목');
    (2) ['가', '나']
    days;
    (7) ['일', '월', '화', '수', '목', '금', '토']
    ```

## 함수를 인자로 가지는 함수

- every(f(x?,i?,a?)) :호출 대상이 되는 배열이 가지고 있는 모든 인자가 전달된 함수 f 의 전달 인자 x 로 전달되었을 때 함수 f 가 참(true)을 반환하는가의 여부를 반환한다. 함수 호출시
  전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    - 예시
    ```
    let nums = [1, 5, 3 ,7 ,11];
    undefined
    nums
    (5) [1, 5, 3, 7, 11]
    nums.every( (x) => x > 0 );
    true 
    ```
- filter(f(x?, i? , a?)) :호출 대상이 되는 배열이 가지고 있는 인다 중 함수 f 의 전달 인자로 참 (true) 을 반환하는 인자만을 인자로 가지는 새로운 배열을 반환한다. 이를 만족하는
  인자가 없다면 반 배열([])을 반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    - 예시
    ```
    let nums = [-1, 13, 6 ,2 ,10 ,-13, 9, 4];
    undefined
    let evens = nums.filter((x) => x % 2 === 0);
    undefined
    evens;
    (4) [6, 2, 10, 4]
    ```
- find(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참 (true)을 반환하는 첫번째 인자를 반환한다. 그러한 인자가 없다면 undefined 를
  반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i: 순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    - 예시
    ```
    let nums = [-1, 13, 6 ,2 ,10 ,-13, 9, 4];
    undefined
    nums.find((x) => x % 2 === 0);
    6
    ```
- findLast(f(x?, i? ,a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 마지막 인자를 반환한다. 그러한 인자가 없다면 undefined
  를 반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
- findIndex(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 첫번째 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1
  을 반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    ```
    let nums = [-1, 13, 6 ,2 ,10 ,-13, 9, 4];
    undefined
    nums.find((x) => x > 5);
    13
    nums.findIndex((x) => x > 5);
    1
    nums.findLast((x) => x > 5);
    9
    nums. findLastIndex((x) => x > 5);
    6
    ```
- forEach(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 전체에 대해 함수 f 의 전달 인자로 해당 함수를 단순 반복 실행한다.
  let fruits = ['Apple', 'Banana', 'Orange','Pineapple', 'Melon'];
  undefined
  fruits.forEach((x) => { console.log(` ${x}은/는 맛잇다.`);});
  VM4219:1 Apple은/는 맛잇다.
  VM4219:1 Banana은/는 맛잇다.
  VM4219:1 Orange은/는 맛잇다.
  VM4219:1 Pineapple은/는 맛잇다.
  VM4219:1 Melon은/는 맛잇다.
  undefined
- map(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 각 인자에 대해 함수 f 의 전달 인자로 반환되는 값으로 치환되는 인자를 각 인자로 가지는 새로운 배열을 반환한다. 함수 호출 시
  전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    ``` 
    let fruits = ['Apple', 'Banana', 'Orange'];
    undefined
    fruits.map((x) => x.length);
    (3) [5, 6, 6]
    fruits.map((x) => x.toUpperCase());
    (3) ['APPLE', 'BANANA', 'ORANGE']; 
    ```
- some(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 하나라도 함수 f 의 전달 인자로 참(true)을 반환하는가의 여부를 반환한다. 함수 호출시 전달되는 인자는 순새대로
  아래와 같고 선택적으로 사용 할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    ```
    let fruits = ['Apple', 'Banana', 'Orange']
    undefined
    fruits.every((x) => x.length === 5);
    false
    fruits.some((x) => x.length === 5);
    true
    ```
- sort(...)
    - sort() :호출 대상이 되는 배열이 가지고 있는 인자가 가지고 있는 값을 문자열 변환하였을 때 가지게되는 유니코드 값을 기준으로 정렬한다.
    - sort(f(a,b)) :호출 대상이 되는 배열이 가지고 있는 인접한 인자들을 각각 a 와 b 라고 하였을때, 비교 함수(Compare Function) f 가 반환하는 값이 0 보다 작을 경우
      a를 b보다 선행하도록(낮은 인덱스)배치한다. 0일 경우 a 와 b 의 배치를 변경하지 않는다. 0 보다 클 경우 b 를 a 보다 선행 하도록 배치한다.
    - 예시
    ```
    let nums = [13, 8, 2, 9 ,5];
     undefined
    nums.sort();
    (5) [13, 2, 5, 8, 9]
    let fruits = ['Apple', 'Banana', 'Orange','Pineapple', 'Melon'];
    undefined
    fruits.sort();
    (5) ['Apple', 'Banana', 'Melon', 'Orange', 'Pineapple']
    let nums = [13,8,2,9,5];
    undefined
    nums.sort((a,b) => a-b);
    (5) [2, 5, 8, 9, 13]
    ```
- reduce(f(c?, x?, i?, a?),s? :호출 대상이 되는 배열이 가지고 있는 인자를 반복하여 누산된 값을 반환한다.
    - c :반복하고 있는 누산기(Accumulator)
    - x :순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i :순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a :호출 대상인 배열
    - s :반복할 누산기(c)의 초기값
    - 예시
    ``` 
    let nums = [13, 8, 2, 9 ,5];
    undefined
    nums.reduce((c,x) => c + x,0)
    37
    ```
## 오브젝트

- 오브젝트(Object)는 키(Key)와 값(Value)으로 이루어진 쌍(Pair)의 집합을 가지는 객체이다.
- 오브젝트의 작성 형태는 JSON(JavaScript Object Notation)Object의 형태와 유사하다.
- 오브젝트는 중괄호({.})로 각 쌍들을 감싸고, 그러한 쌍들이 가지는 키와 값은 콜론(:)으로 구분하며, 하나의 오브젝트는 여러개의 쌍을 쉼표(,)로 구분하여 가질 수 있다.
- 오브젝트가 가지는 쌍들에는 순서가 없음으로 인덱스를 통한 접근이 불가능하다.(인덱스 개념이 없음)
- 오브젝트의 쌍이 가지고 있는 값에는 키를 통해 접근할 수 있고, 하나의 오브젝트가 가지는 동일한 계층의 키는 고유해야한다.
- 오브젝트가 가지는 키는 반드시 문자열이어야 하고 값의 타입에는 제한이 없다.
- 오브젝트의 작성은 아래와 같은 형태로 한다.
    - let [이름] = {
      [키 1]: [값 1],
      [키 2]: [값 2],
      ...
      };
    - 가령, 국가 코드별 한국어 이름을 가지는 오브젝트의 구조는 아래와 같이 작성할 수 있다.
    - 예시
    ```  
    let countryMap = {
    KR:'대한민국',
    US:'미국',
    JP:'일본',
    DE:'독일',
    FR:'프랑스'
    };  
    ```
    - 키 이름을 통해 쌍이 가지는 값에 접근하기 위해서는 오브젝트에 대괄호([,])혹은 멤버 접근(.)연산자를 사용할 수 있다.
    - console.log( countryMap.KR);//대한민국
    - console.log( countryMap['KR']);//대한민국
    - console.log( countryMap['RU']);//undefined
    - 멤버 접근(.)을 통해 접근할 때에는 키 이름을 문자열로 취급하여서는 안 된다.
    - 대괄호([,])를 통해 접근할 때에는 키 이름을 문자열로 취급하여야 한다.
    - 예시
    ```
    let countryMap = {
    KR:'대한민국',
    US:'미국',
    JP:'일본',
    DE:'독일',
    FR:'프랑스' };
    undefined
    countryMap['KR']
    '대한민국'
    let key='JP';
    undefined
    countryMap['key']
    undefined
    countryMap[key]
    '일본'
    ```
## 쌍 추가 및 값 변경

- 오브젝트에 이미 존재하는 쌍의 값을 변경하거나, 존재하지 않는 쌍을 추가하기 위해 아래와 같이 작성할 수 있다.
- [오브젝트].[키]=[값];
- [오브젝트][[키 문자열]]=[값];
- 예시
``` 
countryMap['UE']='영국'
'영국'
countryMap;
{KR: '대한민국', US: '미국', JP: '일본', DE: '독일', FR: '프랑스', …}
DE "독일"
FR "프랑스"
JP "일본"
KR "대한민국"
UE "영국"
US "미국"
```

## 쌍 삭제

- 존재하는 쌍을 삭제하기 위해 아래와 같이 작성할 수 있다.
- delete [오브젝트].[키];
- delete [오브젝트][[키 문자열]];
- 예시
``` 
let countryMap = {
KR:'대한민국',
US:'미국',
JP:'일본',
DE:'독일',
FR:'프랑스' };
undefined
delete countryMap['Jp'];
true
countryMap
{KR: '대한민국', US: '미국', JP: '일본', DE: '독일', FR: '프랑스'}
```

## 정적 함수

- 오브젝트의 정적인 함수는 Object 를 통해 접근한다.
- keys(x): 전달받은 오브젝트 x 가 가지는 키들을 인자로 가지는 1차원 배열을 반환한다.
- values(x):전달받은 오브젝트 x 가 가지는 값들을 인자로 가지는 1차원 배열을 반환한다.
- 예시
```
let countryMap = {
KR:'대한민국',
US:'미국',
JP:'일본',
DE:'독일',
FR:'프랑스' };
undefined
Object.keys(countryMap)
(5) ['KR', 'US', 'JP', 'DE', 'FR']
Object.values(countryMap);
(5) ['대한민국', '미국', '일본', '독일', '프랑스']
Object.keys(countryMap).every((x) => x.length===2)
true
Object.values(countryMap).sort();
(5) ['대한민국', '독일', '미국', '일본', '프랑스']
```

# 카멜 케이스(Camel case)

- **카멜 케이스(Camel case)**는 띄어쓰기를 하지 않고 각 단어의 첫 글자를 대문자로 붙여 쓰되, 전체 단어의 첫 글자는 대문자 또는 소문자로 쓸 수 있는 방식입니다. 이 형식의 이름은 대문자가 낙타
  등의 혹처럼 보이는 데에서 유래했습니다. 읽는 사람이 형상을 쉽게 떠올릴 수 있도록 "camelCase"로 표현하기도 합니다.
- 카멜 케이스는 변수 이름 지정 규칙으로 자주 사용됩니다. 다음의 변수는 모두 카멜 케이스로 작성된 예시입니다. console, encodeURIComponent, ArrayBuffer, HTMLElement.
- URI, HTML과 같이 구문에 약어가 포함된 경우, 카멜 케이스는 다양하게 표현될 수 있습니다. 어떤 사람들은 encodeURIComponent와 같이 약어를 모두 대문자로 표기하는 것을 선호합니다. 이는
  XMLHTTPRequest와 같이 약어가 연속될 경우 모호함을 줄 수 있습니다. 반면 XmlHttpRequest와 같이 약어의 첫 글자만 대문자로 표기하는 것을 선호하는 사람들도 있습니다. 실제 전역 변수인
  XMLHttpRequest는 두 방식을 혼합하여 사용합니다.
- 전체 구문의 첫 글자가 대문자인 경우, 이를 대문자 카멜 케이스 또는 *파스칼 케이스(Pascal case)*라고 합니다. 그렇지 않으면 소문자 카멜 케이스라고 합니다.
- 카멜 케이스는 JavaScript, Java 및 다양한 언어에서 가장 인기 있는 규칙입니다.

# 케밥 케이스(Kebab case)

- **케밥 케이스(Kebab case)**는 띄어쓰기 대신 하이픈 -을 사용하며, 모든 단어를 대체로 소문자로 작성하는 방식입니다. 이 형식은 케밥 꼬치에 고기가 꽂혀 있는 모습과 비슷하여 이와 같은 이름이
  붙여졌습니다. 읽는 사람이 형상을 쉽게 떠올릴 수 있도록 "kebab-case"로 표현되기도 합니다.
- 케밥 케이스(Kebab case)는 변수 이름 지정 규칙으로 자주 사용됩니다. 그러나 많은 언어에서 하이픈은 뺄셈을 나타내므로 케밥 케이스를 사용할 수 없습니다. CSS 속성인 background-color와
  font-family, HTML 속성인 aria-label,data-*는 케밥 케이스로 작성된 것입니다.
- 케밥 케이스로 작성된 단어는 종종 하이픈으로 연결된 단어로 간주됩니다.

## 연산자

### 할당 연산자

- 일반 할당 (`=`): `x = y` 꼴에서 `y` 를 `x` 에 할당한다.

> let x = 5;   
> x = 3;
>
> console.log(x); //3

- 더하기 복합 대입 연산 (`+=`) : `x += y` 꼴에서 `x` 와 `y` 를 합을 `x` 에 재할당한다.
- 빼기 복합 대입 연산 (`-=`) : `x -= y` 꼴에서 `x` 와 `y` 의 차를 `x` 에 재할당한다.
- 곱하기 복합 대입 연산 (`*=`) : `x *= y` 꼴에서 `x` 와 `y` 의 곱을 `x` 에 재할당한다.
- 나누기 복합 대입 연산 (`/=`) : `x /= y` 꼴에서 `x` 를 `y` 로 나눈 몫을 `x` 에 재할당한다.
- 나머지 복합 대입 연산 (`%=`) : `x %= y` 꼴에서 `x` 를 `y` 로 나눈 나머지를 `x` 에 재할당한다.
- 거듭 제곱 복합 대입 연산 (`**=`) : `x **= y` 꼴에서 `x` 의 `y` 제곱을 `x` 에 재할당한다.
- 논리 AND 복합 대입 연산 (`&&=`) : `x &&= y` 꼴에서 `x` 와 `y` 가 모두 참인가의 여부를 `x` 에 재할당한다.
- 논리 OR 복합 대입 연산 (`||=`) : `x ||= y` 꼴에서 `x` 와 `y` 중 하나가 참인가의 여부를 `x`에 재할당한다.
- 널리쉬 병합 복합 대입 연산 (`??=`) : `x ??= y` 꼴에서 `x` 가 널리쉬인 경우 `y` 값을, 아니라면 `x` 값을 재할당한다.

### 비교 연산자

- 동등 (`==`) : `x == y` 꼴에서 `x` 와 `y` 의 값이 같은가의 여부이다. 단, 다른 타입의 피연산자간의 비교를 시도한다.
- 부등 (`!=`) : `x != y` 꼴에서 `x` 와 `y` 의 값이 다른가의 여부이다. 단, 다른 타입의 피연산자간의 비교를 시도한다.
- 일치 (`===`) : `x === y` 꼴에서 `x` 와 `y` 의 값과 타입이 같은가의 여부이다.
- 불일치 (`!==`) : `x !== y` 꼴에서 `x` 와 `y` 의 값 혹은 타입 중 하나 혹은 모두가 다른가의 여부이다.
- 초과 (`>`) : `x > y` 꼴에서 `x` 가 `y` 보다 큰가의 여부이다.
- 미만 (`<`) : `x < y` 꼴에서 `x` 가 `y` 보다 작은가의 여부이다.
- 이상 (`>=`) : `x >= y` 꼴에서 `x` 가 `y` 보다 크거나 같은가의 여부이다.
- 이하 (`<=`) : `x <= y` 꼴에서 `x` 가 `y` 보다 작거나 같은가의 여부이다.
- return boolean : true or false

### 산술 연산자

- 더하기 (`+`) : `x + y` 꼴에서 `x` 와 `y` 의 합이다.
    - 피연산자중 하나 이상이 문자열일 경우 문자열 합치기를 수행한다.
- 빼기 (`-`) : `x - y` 꼴에서 `x` 와 `y` 의 차이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다. (NaN : Not a Number)
- 곱하기 : (`*`) : `x * y` 꼴에서 `x` 와 `y` 의 곱이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다.
- 나누기 (`/`) : `x / y` 꼴에서 `x` 를 `y` 로 나눈 몫이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다.
    - `y` 가 `0` 일 경우 그 결과는 `Infinity` 혹은 `-Infinity` 이다.
- 나머지 (`%`) : `x % y` 꼴에서 `x` 를 `y` 로 나눈 나머지이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다.
    - `y` 가 `0` 일 경우 `NaN` 이다.
- 거듭제곱 (`**`) : `x ** y` 꼴에서 `x` 의 `y` 제곱 (`x`<sup>`y`</sup>)
- 단항 양수 (`+i`) : `+x` 꼴에서 변수 `x` 의 부호를 강조하거나, `x`의 타입이 `number`가 아닐때 `number` 로의 형변환을 시도하게 한다.
- 단한 음수 (`-i`) : `-x` 꼴에서 변수 `x` 의 부호를 반전하거나, `x`의 타입이 `number`가 아닐때 `number` 로의 형변환을 시도하게 한다.
- 증가 (`++`)
    - 전위 증가 : `++x` 꼴에서 구문 실행 전 `x` 에 `1`을 더한다.
    - 후위 증가 : `x++` 꼴에서 구문 실행 후 `x` 에 `1`을 더한다.
- 감소 (`--`)
    - 전위 감소 : `--x` 꼴에서 구문 실행 전 `x` 에 `1` 을 뺀다.
    - 후위 감소 : `x--` 꼴에서 구문 실행 후 `x` 에 `1` 을 뺀다.

> let x = 5;   
> console.log(x + 5); //6   
> console.log(x); //5
>
> console.log(++x); //6   
> console.log(x) //6  
> let y = 5;
>
> console.log(y--); //5   
> console.log(y); //4

### 논리 연산자

- 논리 AND (`&&`) : `x && y` 꼴에서 `x` 와 `y` 가 모두 참(`true`) 인가의 여부이다.
- 논리 OR (`||`) : `x || y` 꼴에서 `x` 와 `y` 중 하나가 참(`true`) 인가의 여부이다. (선행 조건문(x)이 참이면 후행 조건문(y)을 검사하지 않는다.)
- 논리 NOT,부정 (`!`) : `!x` 꼴에서 `x` 의 논리를 부정(반전)한다.

### 삼항 연산자

- 삼항 연상자 (`? :`) : `c ? t : f` 꼴에서 논리 `c` 가 참(`true`) 이라면 `t` 로 , 거짓(`false`) 이라면 `f` 로 연산된다.

> age > 19 ? '성인' : '미성년자'   
> (논리)  ?  (참) :  (거짓)

### 기타 연산자

- 멤버 접근(`.`) : `x.y` 꼴에서 `x` 의 멤버인 `y` 에 접근하기 위해 사용한다.
- 배열 인자 접근(`[]`) : `x[y]` 꼴에서 배열인 `x` 의 인자 중 인덱스가 `y` 인 인자에 접근하기 위해 사용한다.
- 오브젝트 속성 접근(`[]`) : `x[y]` 꼴에서 오브젝트인 `x` 의 쌍 중 키가 `y` 인 쌍에 접근하기 위해 사용한다.
- 객체화(`new`) : `new T` 꼴에서 타입 `T` 를 객체화하기 위해 사용한다.
- 함수 호출(`()`) : `f()` 꼴에서 함수 `f` 를 호출하기 위해 사용한다.
- 우선 연산(`()`) : `(x)` 꼴에서 연산 `x` 를 우선하기 위해 사용한다.
- 삭제 (`delete`) : `delete x.y` 혹은 `delete x['y']` 꼴에서 오브젝트 `x` 의 속성인 `y`를 삭제하기 위해 사용한다.
- `intanceof` : `x instanceof T` 꼴에서 객체 `x` 가 타입 `T` 이거나 상속, 구현 대상인가의 여부이다.
- `typeof` : `typeof x` 꼴에서 `x` 의 타입인 문자열이다.
- 널리쉬 병합 연산자 (`??`) : `x ?? y` 꼴에서 `x` 가 널리쉬 일때 `y` 값으로 연산되고, 그렇지 않으면 `x` 그대로 연산된다. 할당하지 않는다.
- 옵셔널 체이닝 멤버 접근 연산자 (`?.`) : `x?.y` 꼴에서 `x` 의 멤버인 `y` 에 접근할 때 `x` 가 널리쉬라면, 오류를 발생시키는 대신, 전체 결과를 `undifined` 로 갈음한다.

> el?.value ?? '(없음)'   
> undefined ?? '(없음)'

### 연산자 우선순위

- 연산자 사이에는 연산되는 우선순위가 있으며 아래는 숫자가 작을수록 우선순위가 높다는 의미이다.

1. 우선 연산(`()`)
2. 멤버 접근, 옵셔널 체이닝 멤버 접근, 배열 인자 접근, 오브젝트 속성 접근(`.`, `?.`, `[]`, `[]`)
3. 객체화, 함수 호출(`new`, `()`)
4. 논리 NOT, 단항 양수, 단항 음수, `typeof`, `delete`(`!`, `+`, `-`)
5. 거듭 제곱(`**`)
6. 곱하기, 나누기, 나머지(`*`, `/`, `%`)
7. 더하기, 빼기 (`+`, `-`)
8. 초과, 미만, 이상 ,이하, `instanceof`(`>`, `<`, `>=`, `<=`)
9. 동등, 부등, 일치, 불일치(`==`, `!=`, `===`, `!==`)
10. 논리 AND(`&&`)
11. 논리 OR(`||`)
12. 널리쉬 병합 연산(`??`)
13. 삼항 연산(`? :`)
14. 일반 할당, 복합 대입 연산(`=` 등)

## 반복문

### 키워드

#### break

- `break` 키워드는 속해있는 반복문을 종료시키기 위해 사용한다.

#### continue

- `continue` 키워드는 현재 진행중인 사이클을 종료하고, 다음 사이클로 진행하기 위해 사용한다.

### for

- `for`반복문은 반복의 기준이 되는 변수(주로 인덱스)를 활용하여 특정 구현부를 반복하고자 할 때 사용한다.

>       for ([변수 선언 및 초기화]; [반복 조건]; [변수 가감 혹은 복합 대입]) {   
>           [구현부]   
>       }
> 1. `for`반복문을 위한 `변수선언` 및 `초기화`한다.
> 2. `반복 조건`이 참(`true`)인지 확인한다.
     >

- `반복 조건`이 참(`true`)이라면 `구현부`를 1회 실행하고, `3번`으로 이동한다.

> - `반복 조건`이 거짓(`false`)이라면, 반복문 실행을 종료한다.
> 3. 변수 가감 혹은 복합 대입을 실행하고 `2번`으로 돌아간다.

### for ... in

- `for ...in` 반복문은 문자열로 키가 지정된 열거 가능한 대상의 키를 반복하기 위해 사용한다.
- 반복 대상의 인자가 인덱스를 가지고 순서대로 나열되어 있는 경우 `for ...in` 을 사용하지 않는다.

>       for ([변수 혹은 상수 선언] in [반복 대상]) {   
>           [구현부]   
>       } 
> - 반복 대상은 주로 Object이다. for (const key in value) {}

### for ... of

- `for ...of` 반복문은 반복할 수 있는 대상이 가지는 인자에 대해 반복하기 위해 사용한다.
- **인덱스에 대한 변수가 필요 없을 경우** 인덱스 범위 오류 및 가독성 향상 등을 위해 가능한한 일반 `for` 반복문 보다 `for ...of` 반복문을 사용하는 것이 좋다.

>       for ([변수 혹은 상수 선언) of [반복대상]) {   
>           [구현부]   
>       }

### while

- `while` 반복문은 주어진 조건이 참(`true`)일때 횟수와 관계 없이 구현부를 실행하기 위해 사용한다.

>       while ([조건] {   
>           [구현부]   
>       }
> - 만약 `조건`이 항상 참(`true`)이거나, 거짓(`false`)으로 변하는 경우의 수가 없고, 구현부 내에 `break` 및 `return` 등의 중단 키워드가 없다면, 해당 반복문이 무한히 반복됨으로
    유의한다.

### do ... while

- `do ... while` 반목문은 `while` 반복문과 유사하나, 조건과 관계없이 최초 한번은 반드시 구현부를 실행한다는 차이점이 있다.

>       do { 
>           [구현부]   
>       } while ([조건]);
>
> - 만약 `조건`이 항상 참(`true`)이거나, 거짓(`false`)으로 변하는 경우의 수가 없고, 구현부 내에 `break` 및 `return` 등의 중단 키워드가 없다면, 해당 반복문이 무한히 반복됨으로
    유의한다.

## 조건문

### if

- 주어진 조건이 참일때만 구현부를 실행하기 위해 사용한다.

>       if ([조건]) {   
>           [구현부]   
>       }

### else

- `else` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else` 문은 앞서 제시된 모든 조건이 거짓일때 최종적으로 실행할 구현부를 위해 사용한다.
- `else` 문은 `if`문 하나에 여러개 존재할 수 없다.
- `else` 문은 `if`문의 마지막 구문이어야 한다.

>       if ([조건]) {   
>           [참 구현부]   
>       } else {   
>           [거짓 구현부]   
>       }

### else if

- `else if` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else if` 문은 앞서 제시된 모든 조건이 거짓일때 부수적인 조건을 추가하여 해당 조건이 참일때 구현부를 실행하기 위해 사용한다.
- `else if` 문은 `if` 문 하나에 여러개 존재할 수 있다.
- `else if` 문은 조건이 비록 참이라 하더라도 선행하는 `if` 혹은 `else if` 의 조건이 참이라면 해당 후행하는 `else if` 는 실행되지 않는다. (하나의 `if` 문에서 실행될 수 있는
  구현부는 하나 이하임으로)
- 모든 `else if` 는 `if` 보다 후행하고 `else` 보다 선행하여야 한다.

>       if ([선행 조건 1]) {   
>           [선행 조건 1 구현부]   
>       } else if ([선행 조건 2]) {   
>           [선행 조건 2 구현부]   
>       } else if ([선행 조건 3]) {   
>           [선행 조건 3 구현부]   
>       } else {   
>           [거짓 구현부]   
>       } 
> - 위 예시에서 `선행 조건 1` 이 참인 경우 `선행 조건 1 구현부` 를 실행하고 나머지 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 이 거짓이고 `선행 조건 2` 가 참인 경우 `선행 조건 2 구현부` 를 실행하고 후행하는 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 및 `선행 조건 2` 가 거짓이고 `선행 조건 3` 이 참인 경우 `선행 조건 3 구현부` 를 실행하고 후행하는 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1`, `선행 조건 2`, `선행 조건 3` 이 모두 거짓이라면 `else`를 실행한다.
> - 즉, `else if` 의 개수와 무관하게 하나의 `if` 문에 존재하는 구현부는 실행되지 않거나, 단 한 개만 실행될 수 있다.

### switch

- `switch` 문은 `분기 대상 변수` 가 가지는 값에 따라 `case` 를 활용하여 실행할 구문을 분리하기 위해 사용한다.

>       switch ([분기 대상 변수]) {   
>           case [값 1]:   
>               [값 1 구현부]   
>               [break;]?   
>           case [값 2]:   
>               [값 2 구현부]   
>               [break;]?  
>           [default:]?   
>               [default 구현부]?   
>       }
> - `분기 대상 변수` 가 가지는 값이 `case` 에 명시된 `값` 과 일치하는 가장빠른 `case` 의 구현부가 실행된다.
> - 일치하는 `case` 가 없다면 `default` 구현부가 실행된다.
> - `break` 키워드는 해당 위치에서 즉시 `switch` 문을 종료하겠다는 의미이다.
> - `default` 는 여러개 존재할 수 없으며 작성시 반드시 `switch` 의 마지막에 위치해야 한다.

- break 키워드가 없으면, 일치하는 케이스 포함한 아래의 모든 코드를 실행한다.

## 함수

- 함수(Function)는 호출(Call, Invoke)가능한 대상이다.
- 함수는 반복적으로 여러곳에서 사용될 가능성이 높은 로직을 분리하기 위해 사용한다.
- 하나의 함수는 하나의 목적을 가지는 로직을 구현하는 것이 좋다.
- 함수의 명명법은 카멜 케이스이고 주로 아래의 형태를 가진다.
    - `[동사]`
    - `[동사][목적어]`
    - `to[목적어]`

### 함수 호출

- 함수는 종류를 구분하지 않고 아래와 같이 호출할 수 있다.

>       [함수이름]([전달 인자, ...]?);   
> - 가령, `console` 의 멤버인 `log` 라는 이름을 가지느 함수에 전달 인자 `Hello World` 를 전달하여 호출하는 표현은 아래와 같다.
>
>
>       console.log('Hello World');   

## 일반 함수

### 기명 함수

- 기명 함수는 이름이 있는 함수로 아래와 같이 작성한다.

>       function [함수 이름] ([매개 변수, ...]?) {
>           [구현부]
>       }
> - 가령, 전달 받은 매개 변수 `a` 와 `b` 의 합을 반환하기 위한 함수 `sum` 은 아래와 같이 만들 수 있다.
>
>
>       function sum (a, b) {   
>           return a + b;   
>       }
> - `return` 키워드는 해당 함수의 호출 경과를 호출자에게 반환하기 위해 사용한다.
> - `return` 키워드는 해당 위치에서 해당 함수의 실행을 즉시 종료한다. 이에, 반환값 없이 해당 함수의 실행을 고의로 종료하기 위해 `return;` 만 작성하기도 한다.
> - 값이 반환하거나 (`return;`) 반환하지 않은 경우, 해당 함수의 호출 결과는 `undefined` 이다.

### 익명 함수

- 이름이 없는 함수로, 단독 사용이 불가하며 주로 생성 후 변수나 상수에 할당하거나, 다른 함수의 호출시 인자로 활용한다.

>       function ([매개 변수, ...]) {   
>           [구현부]   
>       }

### 화살표 함수

- 화살표 함수(Arrow Function)는 함수의 일종으로 이름이 없고, 변수나 상수에 할당하거나, 다른 함수의 호출시 인자로 활용할 수 있다.

>       ([매개 변수,...]?) => {   
>           [구현부]   
>       }   
>
> - 매개 변수가 하나만 존재하는 경우, 매개 변수를 위한 괄호를 생략할 수 있다.
    >
    >       const f = (x) => {   
    >           return x ** 2;   
    >       }

    >       const f = x => {   
    >          return x ** 2;
    >       }
>
> - 구현부가 **하나의 구문**으로 이루어진 경우 **중괄호**(`{` , `}`)를 생략할 수 있는데, 이때 해당 구문의 실행 결과는 **반환**(`return`)됨으로 `return` 키워드 또한 생략한다.

## 요소

## window

- `window` 객체는 자바스크립트의 최상위 객체이면서 브라우저와 관련된, HTML 문서 및 이를 초월하는 멤버를 모두 가지고 있다.
- 전역적으로 사용할 수 있는 대상이 모두 `window` 객체의 멤버로 할당되어 있다.
-

### document

- `window`의 멤버로, HTML 문서 (`<html>` 부터 `</html>` 까지)에 대한 멤버를 가지는 객체이다.
- 속성
    - `head` : `<head>` 태그에 대한 멤버를 가지는 객체이다.
    - `body` : `<body>` 태그에 대한 멤버를 가지는 객체이다.
- 함수
    - `createElement(x)` : 태그의 종류가 `x` 인 **가상의 요소**를 만들어 반환한다.
    - `getElementById(x)` : HTML `id` 속성 값으로 문자열인 `x` 를 가지는 요소를 선택하여 반환한다. 그러한 요소가 없다면 `null` 을 반환한다.

### HTMLElement

- `HTMLElement` 는 HTML의 모든 태그를 자바스크립트 객체로 표현하기 위한 타입이다.
- 객체 속성
    - `classList` : 해당 요소의 HTML `class` 속성과 관련된 멤버를 가지고 있는 속성이다.
        - `add(x)` : 해당 요소의 `class` 속성에 `x`를 추가한다. 이미 있다면 중복되게 추가하지는 않으며, 공백을 추가하는 등 다른 클래스와의 분리는 자동으로 이루어진다.
        - `remove(x)` : 해당 요소의 `class` 속성에서 `x` 를 제거한다.
        - `toggle(x)` : 해당 요소의 `class` 속성이 `x` 를 가지고 있다면 제거하고, 없다면 추가한다.
        - `contains(x)` : 해당 요소의 `class` 속성이 `x` 를 가지고 있는가의 여부를 반환한다.
    - `dataset` : 해당 요소의 사용자 지정 데이터를 가져오거나 지정하기 위한 속성이다. 오브젝트 속정 접근 연산자(`[]`)를 활용하여 해당 요소가 가지고 있는 `data-*` 속성의 이름으로 값에
      접근할 수 있다. 단, 접근시 이름을 카멜 케이스화 하여야 함에 유의한다. (가령, HTML상 그 속성 이름이 `data-member-name` 인 대상에 접근하고자 한다면 `daraset[`
      memberName`]`으로 접근)
    - `innerHTML` : 해당 요소의 내부 HTML **코드**인 문자열이다.
    - `innerText` : 해당 요소의 내부 **텍스트** 내용인 문자열이다.
    - `style` : 해당 요소의 CSS와 관련된 멤버를 가지고 있는 속성이다. 해당 속성 사용시, 해당 요소의 `style` 속성이 부여된다.
        - 해당 속성의 멤버의 명명은 실제 CSS 속성을 카멜 케이스화 한 것임에 유의한다. (가령, `background-color` 는 `backgroundColor` 로 사용)
        - 부여한 CSS 속성을 삭제하고자 한다면 해당 속성 값을 빈 문자열로 지정한다.
- 객체 함수
    - `addEventListener(e, f)` : 호출 대상인 요소에 이벤트 `e` 가 발생하였을 때 함수 `f` 를 실행하기 위한 이벤트 리스너를 추가한다.
    - `removeEventListener(e, f)` : 호출 대상인 요소가 가지고 있는 이벤트 리스너 중 이벤트의 종류가 `e` 이고 함수가 `f` 인 이벤트 리스너를 제거한다. 여기서 제거할 함수 `f`
      는 이벤트 리스너 추가시 사용한 함수와 동일한 대상이어야 한다.
    - `append(...x)` : 호출 대상인 요소의 마지막 자식이 될 수 있도록 한 개 이상의 요소 `x` 를 추가한다.
    - `prepend(...x)` : 호출 대상인 요소의 첫번째 자식이 될 수 있도록 한 개 이상의 요소 `x` 를 추가한다.
    ```
    const $input = document.createElement('input');
  
    document.body.append($input); 
    document.body.prepend($input);
    ```
    - `insertAdjacentElement(p, x)` : 호출 대상인 요소에 대해 지정한 포지션 `p` 에 맞게 요소 `x` 를 배치한다. `p` 값은 아래와 같다.
        - `beforebegin` : 요소가 열리기 전(요소의 인접 선행)
        - `afterbegin` : 요소가 열리고 난 뒤(요소의 첫번째 자식)
        - `beforeend` : 요소가 닫히기 전(요소의 마지막 자식)
        - `afterend` : 요소가 닫히고 난 뒤(요소의 인접 후행)
      ```
      insertAdjacentEelement(beforebeign, x)
      <div>
      insertAdjacentEelement(afterbegin, x)
      insertAdjacentEelement(beforeend, x)
      </div>
      insertAdjacentEelement(afterend, x)
      ```
    - `querySelector(x)` : 호출 대상이 되는 요소의 자식 혹은 자손이면서 CSS 선택자인 문자열 `x` 를 가장 빨리 만족하는 요소 한 개를 반환한다. 그러한 요소가 없다면 `null`
          을 반환한다.
    - `querySelectorAll(x)` : 호출 대상이 되는 요소의 자식 혹은 자손이면서 CSS 선택자인 문자열 `x` 를 만족하는 요소 전체를 인자로 가지는 유사 배열 객체 `NodeList` 를
          반환한다. 그러한 요소가 없다면 길이가 `0` 인 유사 배열 객체 `NodeList` 를 반환한다.
        - (차이점 : document.getElementById() 와는 다르게 document.body.querySelector()(= Element.querySelector())처럼 원하는 범위에 사용
          가능하다)
        - `const $direct = $p.querySelectorAll(':scope > .c');` 자손은 빼고 자식만 선택하고 싶을때 `:scope >` 를 사용한다. 여기서 scope는 자신(
          `$p`)을 뜻한다
- 이벤트
    - `click` : 클릭했을때의 이벤트
    - `mousedown` : 마우스 버튼을 눌렀을때의 이벤트
    - `mouseup` : 마우스 버튼을 뗐을때의 이벤트 (요소 밖에서 마우스를 누르고, 요소 안에서 떼도 작동한다.)
    - `mouseenter` : 마우스 커서가 해당 요소의 밖에 있다가 내부로 진입했을때의 이벤트
    - `mouseleave` : 마우스 커서가 해당 요소의 안에 있다가 외부로 빠져 나갔을때의 이벤트
    - `mousemove` : 마우스 커서가 해당 요소의 위에서 움직일때의 이벤트 (복잡한 함수에 사용하지 않는 것이 좋다.)
    - `wheel` : 마우스 휠이 돌아갔을 때의 이벤트
    - `focusin` : 포커스를 가질 수 있는 요소가 포커스를 가지게 되었을 때의 이벤트
    - `focusout` : 포커스를 가질 수 잇는 요소가 포커스를 잃었을 때의 이벤트
    - `keydowm` : 포커스를 가질 수 있는 요소가 포커스를 가지고 있고 키보드의 키가 눌렸을 때의 이벤트
    - `keyup` : 포커스를 가질 수 있는 요소가 포커스를 가지고 있고 키보드의 키가 떼졌을 때의 이벤트
    - `change` : `input`, `select` 혹은 `textarea` 태그의 내용이나 상태(체크 등)가 사용자에 의해 변경되었을때 발생하는 이벤트
    - `input` : `input`, `select` 혹은 `textarea` 태그의 내용이나 상태(체크 등)가 사용자에 의해 변경되었을때 발생하는 이벤트 (`change` 와 큰 구분 없이 사용한다.)

### HTMLInputElement

- `HTMLInputElement` 는 `HTMLElement` 타입을 상속 받는 `input` 태그를 자바스크립트 객체로 표현하기 위한 타입이다.
- 객체 속성
  - `checked` : 해당 요소의 `type` 속성 값이 `checkbox` 혹은 `radio` 일때, 해당 요소가 체크되어 있는지의 여부를 가지고 오거나 지정한다.
  - `disalbed` : 해당 요소가 비활성화되어 있는지의 여부를 가지고 오거나 지정한다.
  - `value` : 해당 요소가 가지고 있는 값을 가지고 오거나 지정한다.
- 객체 함수
  - `focus` : 해당 요소가 포커스를 가지게 한다.
  - `select` : 해당 요소가 가지고 있는 텍스트 내용을 모두 선택한다.


### HTMLSelectElement

- `HTMLSelectElement` 는 `HTMLElement` 타입을 상속 받는 `select` 태그를 자바스크립트 객체로 표현하기 위한 타입이다.
- 객체 속성
    - `disalbed` : 해당 요소가 비활성화되어 있는지의 여부를 가지고 오거나 지정한다.
    - `value` : 해당 요소가 가지고 있는 값을 가지고 오거나 지정한다.
- 객체 함수
    - `focus` : 해당 요소가 포커스르 가지게 한다.


### HTMLTextAreaElement

- `HTMLTextAreaElement` 는 `HTMLElement` 타입을 상속 받는 `textarea` 태그를 자바스크립트 객체로 표현하기 위한 타입이다.
- 객체 속성
    - `disalbed` : 해당 요소가 비활성화되어 있는지의 여부를 가지고 오거나 지정한다.
    - `value` : 해당 요소가 가지고 있는 값을 가지고 오거나 지정한다.
- 객체 함수
    - `focus` : 해당 요소가 포커스르 가지게 한다.
    - `select` : 해당 요소가 가지고 있는 텍스트 내용을 모두 선택한다.

## 기타

- `alert(x)` : 문자열인 `x` 를 내용으로 가지는 메세지를 출력한다.
- `confirm(x)` : 문자열인 `x` 를 내용을 가지는 메세지를 출력한다. 단, 확인과 취소버튼을 가지며, 확인(긍정)버튼을 클릭할 경우 해당 함수의 호출 결과로 참(`true`), 취소(부정)버튼을 클릭할 경우 해당 함수의 호출 결과로 거짓(`false`)이 반환된다.
- `isNaN(x)` : 숫자인 `x` 가 `NaN` 인가의 여부를 반환한다. (`NaN` 간의 동등, 일치 연산(`NaN` === `NaN`)은 `false` 를 반환함으로 `isNaN` 함수를 사용한다.)
- `setInterval(f, m)` : 숫자인 `m` 밀리초마다 함수 `f` 를 실행한다. 해당 인터벌의 식별자인 숫자를 호출 결과로 반환한다.
- `setTimeout(f, m)` : 숫자인 `m` 밀리초 후에 함수 `f` 를 1회 실행한다. 해당 타임아웃의 식별자인 숫자를 호출 결과로 반환한다.
- `clearInterval(x)` : `setInterval` 함수 호출 결과로 반환된 식별자를 `x` 로 전달하여 반복을 해제한다.
- `clearTimeout(x)` : `setTimeout` 함수 호출 결과로 반환된 식별자를 `x` 로 전달하여 예약을 해제한다.
- `parseInt(s)` : 문자열인 `s` 를 정수인 숫자로 변환하여 반환한다. 인식되는 소수점은 모두 버려지며, 숫자로 변환할 수 없을 때에는 `NaN` 을 반환한다.
- `parseFloat(s)` : 문자열인 `s` 를 소수로 변환하여 반환한다. 숫자로 변환할 수 없을때에는 `NaN` 을 반환한다.


## String

- `string` 은 자바 스크립트에서 문자열을 표현하기 위한 타입이다.
- 객체 속성
  - `length` : 문자열의 길이
- 객체 메서드
  - `at(x)` : 문자열이 가지고 있는 인덱스가 `x` 인 문자열을 반환한다.
  - `concat(x)` : 호출 대상인 문자열과 문자열인 인자 `x` 를 이어붙인 새로운 문자열을 반환한다.
  - `includes(x)` : 호출 대상인 문자열의 내용이 문자열인 인자 `x` 를 포함하는가의 여부를 반환한다.
  - `startsWith(x)` : 호출대상인 문자열이 문자열인 인자 `x` 로 시작하는가의 여부를 반환한다.
  - `endsWith(x)` : 호출대상인 문자열이 문자열인 인자 `x` 로 끝나는가의 여부를 반환한다.
  - `padEnd(n, s)` : 호출 대상인 문자열의 길이가 `n` 자 이하일때 `n` 자가 될 수 있도록 부족한 만큼 문자열 `s` 를 문자열 끝에 추가한다.
  - `padStart(n, s)` : 호출 대상인 문자열의 길이가 `n` 자 이하일때 `n` 자가 될 수 있도록 부족한 만큼 문자열 `s` 를 문자열 앞에 추가한다.
  - `repeat(t)` : 호출 대상인 문자열을 숫자인 인자 `t` 번 만큼 반복한 문자열을 반환한다.
  - `replaceAll(f, t)` : 호출 대상인 문자열에서 문자열 혹은 정규표현식인 `f` 를 찾아 문자열인 `t` 로 치환한 새로운 문자열을 반환한다.
  - `slice(...)` 
    - `slice()` : 호출 대상인 문자열이 가지고 있는 내용을 그대로 가지는 문자열을 복사하여 반환한다.
    - `slice(f)` : 호출 대상인 문자열이 가지고 있는 내용 중 인덱스가 `f` 이상인 문자열을 내용으로 가지는 문자열을 복사하여 반환한다.
    - `slice(f, t)` : 호출 대상인 문자열이 가지고 있는 내용 중 인덱스가 `f` 이상, `t` 미만인 문자열을 내용으로 가지는 문자열을 복사하여 반환한다.
  - `substring(f, t)` : 호출 대상인 문자열이 가지고 있는 내용 중 인덱스가 `f` 이상, `t` 미만인 문자열을 내용으로 가지는 문자열을 복사하여 반환한다. **사용**
  - `toLowerCase()` : 호출 대상인 문자열이 가지고 있는 내용 중 인식 가능한 라틴 문자를 소문자화한 새로운 문자열을 반환한다.
  - `toUpperCase()` : 호출 대상인 문자열이 가지고 있는 내용 중 인식 가능한 라틴 문자를 대문자화한 새로운 문자열을 반환한다.
  - `trim()` : 호출 대상인 문자열이 가지고 있는 내용 중 시작과 끝의 연속되는 공백을 모두 제거하여 반환한다.
  - `trimStart()` : 호출 대상인 문자열이 가지고 있는 내용 중 시작점의 연속되는 공백을 모두 제거하여 반환한다.
  - `trimEnd()` : 호출 대상인 문자열이 가지고 있는 내용 중 끝점의 연속되는 공백을 모두 제거하여 반환한다.


## Math

- `math` 크래스는 주로 수학과 관련된 멤버를 포함하는 유틸리티 클래스이다.
- 정적 속성
  - `E` : 오일러 상수. 약 `2.718`
  - `LN2` : `2` 의 자연로그. 약 `0.693`
  - `LN10` : `10` 의 자연로그. 약 `2.303`
  - `LOG2E` : 밑이 `2` 인 로그 E. 약 `1.443`
  - `LOG10E` : 밑이 `10` 인 로그 E. 약 `0.434`
  - `PI` : 원주율. 약 `3.141`
  - `SQRT1_2` : `0.5` (`1/2`)의 제곱근. 약 `0.707`
  - `SQRT2` : `2`의 제곱근. 약 `1.1414`
- 정적 함수
  - `abs(x)` : 숫자인 `x` 의 절댓값을 반환한다. **!**
  - `cbrt(x)` : 숫자인 `x` 의 세제곱근을 반환한다. **!**
  - `sqrt(x)` : 숫자인 `x` 의 제곱근을 반환한다. **!** 
  - `ceil(x)` : 숫자인 `x` 를 정수부까지 올림하여 반환한다. **!**
  - `floor(x)` : 숫자인 `x` 를 정수부까지 내림하여 반환한다. **!**
  - `round(x)` : 숫자인 `x` 를 정수부까지 반올림하여 반환한다. **!**
  - `trunc(x)` : 숫자인 `x` 의 소수부를 버리고 반환한다. **!**
  - `Math.max(...n)` : 숫자를 인자로 가지는 가변인자 `n` 중 가장 큰 값을 반환한다. **!**
  - `Math.min(...n)` : 숫자를 인자로 가지는 가변인자 `n` 중 가장 작은 값을 반환한다. **!**
  - `Math.sign(x)` : 숫자인 `x` 의 부호를 반환한다. 양수인 경우 `1`, 음수인 경우 `-1`, `0` 인 경우 `0`, 그 외의 경우 `NaN` 을 반환한다.
  - `log(x)` : 숫자인 `x` 의 자연로그 값을 반환한다.
  - `log10(x)` : 숫자인 `x` 의 밑이 10인 자연로그 값을 반환한다.
  - `log2(x)` : 숫자인 `x` 의 밑이 2인 자연로그 값을 반환한다.
  - `acos(x)` : 숫자인 `x` 의 아크코사인 값을 반환한다.
  - `acosh(x)` : 숫자인 `x` 의 쌍곡 아크코사인 값을 반환한다.
  - `asin(x)` : 숫자인 `x` 의 아크사인 값을 반환한다.
  - `asinh(x)` : 숫자인 `x` 의 쌍곡 아크사인 값을 반환한다.
  - `atna(x)` : 숫자인 `x` 의 아크탄젠트 값을 반환한다.
  - `atanh(x)` : 숫자인 `x` 의 쌍곡 아크탄젠트 값을 반환한다.
  - `atan2(x, y)` : 인수 몫의 아크탄젠트 값을 반환한다.
  - `cos(x)` : 숫자인 `x` 의 코사인 값을 반환한다.
  - `cosh(x)` : 숫자인 `x` 의 쌍곡 코사인 값을 반환한다.
  - `sin(x)` : 숫자인 `x` 의 사인 값을 반환한다.
  - `sinh(x)` : 숫자인 `x` 의 쌍곡 사인 값을 반환한다.
  - `tan(x)` : 숫자인 `x` 의 탄젠트 값을 반환한다.
  - `tanh(x)` : 숫자인 `x` 의 쌍곡 탄젠트 값을 반환한다.

    ```
    // 전달받은 숫자 num에 대해
    // 소숫점 digit 자리까지 반올림하여
    // 반환하는 함수 customRound를 완성하세요
    // 단, num은 항상 숫자이며 digit은 0이상의 자연수입니다.
    
    function customRound (num, digit) {
        //Math.round(num * 10**digit)/10**digit;
        const factor = 10 ** digit;
        num *= factor;
        num = Math.round(num);
        num /= factor;
        return num;
    }
    ``` 

 
## Number

- `Number` 클래스는 자바스크립트의 숫자 타입이기도 하고, 숫자와 관련된 유틸리티 멤버를 제공하기도 한다.
- 정적 속성
  - `MAX_SAFE_INTEGER` : 자바스크립트에서 표현 가능한 안전한 최대 정수(<code>2<sup>53</sup>-1</code>)
  - `MIN_SAFE_INTEGER` : 자바스크립트에서 표현 가능한 안전한 최소 정수(<code>-(2<sup>53</sup>-1)</code>)
  - `MAX_VALUE` : 자바스크립트에서 표현 가능한 가장 큰 수
  - `MIN_VALUE` : 자바스크립트에서 표현 가능한 가장 작은 양수
  - `NaN` : 숫자가 아닌 값(Not a Number)
  - `POSITIVE_INFINITY` : 양의 무한대
  - `NEGATIVE_INFINITY` : 음의 무한대
- 정적 함수
  - `isNaN(x)` : 전달된 값 `x` 가 `NaN` 인가의 여부를 반환한다. **(`window.isNaN` 함수와 다르다.)**
  - `isFinite(x)` : 전달된 숫자 `x` 가 유한한지의 여부를 반환한다. (`window.isFinite` 함수와 다르다.)
  - `isInteger(x)` : 전달된 숫자 `x` 가 정수인지의 여부를 반환한다.
  - `isSafeInteger(x)` : 전달된 숫자 `x` 가 안전한 정수(`Number.MIN_SAFE_INTEGER` 이상이고 `Number.MAX_SAFE_INTEGER` 이하)인지의 여부를 반환한다.
  - `parseFloat(x)` : 전달된 값 `x` 를 실수로 변환하여 반환한다. 변환할 수 없을 경우 `NaN` 을 반환한다. (`window.parseFloat` 과 동일한 함수이다.)
  - `parseInt(...)`
    - `parseInt(x)` : 전달된 값 `x` 를 정수로 변환하여 반환한다. 변환할 수 없을 경우 `NaN` 을 반환한다. (`window.parseInt` 와 동인한 함수이다.)
    - `parseInt(x, r)` : 전달된 값 `x` 를 `r` 진법으로 인식하여 10진수인 정수로 변환하여 반환한다. 변환할 수 없을 경우 `NaN` 을 반환한다. (`window.parseInt` 와 동인한 함수이다.)
- 객체 함수
  - `toFixed(d)` : 전달된 자연수 `d` 를 자리수로 가지는 고정 소수점 표기법으로 숫자를 표현한 문자열을 반환한다.
  - `toLocaleString(...)`
    - `toLocaleString()` : 호출 대상이 가지고 있는 값을 현재 브라우저를 구동 중인 운영체제의 언어 설정에 맞게 포맷한 문자열을 반환한다.
    - `toLocaleString(c)` : 호출 대상이 가지고 있는 값을 전달 받은 로케일 코드 `c` 에 맞게 포맷한 문자열을 반환한다.
  - `toString(...)` 
    - `toString()` : 호출 대상이 가지고 있는 값을 문자열로 변환하여 반환한다. 별도의 조치를 취하지 않는다.
    - `toString(r)` : 호출 대상이 가지고 있는 10진법 값을 전달 받은 자연수(`2` 이상 `36` 이하)인 `r` 진법인 문자열로 변환하여 반환한다.


## JSON

- `JSON` 클래스는 주로 자바스킯트의 배열(`[...]`) 및 오브젝트 (`[...]`) 와 JSON(JavaScript Object Notation) 자료형간의 연계를 위한 유틸리티를 제공하는 클래스이다.
- 정적 함수
    - `parse(x)` : 전달 받은 문자열인 `x` 를 분석하여 자바스크립트의 배열이나 오브젝트로 반환한다.
    - `stringify(x)` : 전달 받은 배열 혹은 오브젝트인 `x` 를 문자열로 변환하여 반환한다.


## XMLHttpRequest(XHR)

- XMLHttpRequest(XHR) 클래스는 자바스크립트에서 **비동기(Asynchronous)** 통신을 수행하기 위해 사용한다.
- 페이지를 새로 고치지 않고, 비동기적으로 서버에 요청을 보내고 응답을 받아오기 위해 사용한다.
- 외부 리소스를 불러옴에 있어 페이지를 다시 불러올 필요가 없기 때문에, 사용가 경험(UX, User Experience)에 긍정적인 영향을 줌으로 많이 사용한다.
- 일반적으로 아래 구조와 같이 구현할 수 있다.

>       const xhr = new XMLHttpRequest();
>       xhr.onreadystatechange = () => {
>           if (xhr.readyState !== XMLHttpRequest.DONE) {
>               return;
>           }
>           if (xhr.statue < 200 || xhr.status >= 400) {
>               [요청 실패 로직 작성]
>               return;
>           }
>           [요청 성공 로직 작성]
>       };
>       xhr.open([요청 방식], [요청 주소]);
>       xhr.send([요청 데이터]?);
>
>
>  - `XMLHttpRequest` 객체의 `onreadystatechange` 이벤트는 해당 객체의 상태(Ready State)가 변화할 때마다 실행할 함수를 가진다.
>  - `XMLHttpRequest` 객체의 'open' 함수는 요청을 전송할 방식과 주소를 지정할 뿐, 실제 요청을 전송하는 것은 아님에 유의한다.
>  - `XMLHttpRequest` 객체의 'send' 함수는 준비된 데이터와 위에서 설정한 방식, 주소에 따라 요청을 실제로 전송한다.
>  - 엄밀히 간략하게 작성하면 아래와 같이 작성할 수 있으나, 위에서 작성한 코드가 패턴화 되어있다고 볼 수 있다.
>
>
>       const xhr = new XMLHttpRequest();
>       xhr.onreadystatechange = [상태 변화 이벤트 함수];
>       xhr.open([요청 방식], [요청 주소]);
>       xhr.send([요청 데이터)?];

- 정적 속성
    - `UNSENT` : `XMLHttpRequest` 타입의 객체의 `readyState` 속성이 가징 수 있는 값으로 `0` 과 같고, `XMLHttpRequest` 객체가 객체화된 후 아무런 동작을 하지
      않은 초기 상태이다. (`open` 함수 호출 전) `const xhr = new XMLHttpRequest();`
    - `OPENED` : `XMLHttpRequest` 타입의 객체의 `readyState` 속성이 가징 수 있는 값으로 `1` 과 같고, `open` 함수를 호출한 후의 상태이다. 단, 아직 요청이 외부로
      전송된 것은 아님에 유의한다.
    - `HEADERS_RECEIVED` : `XMLHttpRequest` 타입의 객체의 `readyState` 속성이 가징 수 있는 값으로 `2` 와 같고, `send` 함수를 호출한 후의 상태이다. 응답
      헤더(Response Headers)와 상태 코드(Status Code)에 접근할 수 있다.
    - `LOADING` : `XMLHttpRequest` 타입의 객체의 `readyState` 속성이 가징 수 있는 값으로 `3` 과 같고, 응답 본문(Response Body)을 받아오는 중으로, 일반적으로
      **다운로드 중**이라고 표현한다.
    - `DONE` : `XMLHttpRequest` 타입의 객체의 `readyState` 속성이 가징 수 있는 값으로 `4` 와 같고, 모든 작업이 끝났음을 의미한다. 단, 이는 성공 여부를 의미하는 것이
      아님에 유의한다.

- 객체 속성
    - `readyState` : 해당 객체의 대기 상태. 가질 수 있는 값은 `XMLHttpRequest.UNSENT`, `XMLHttpRequest.OPENED`,
      `XMLHttpRequest.HEADERS_RECIEVED`, `XMLHttpRequest.LOADING`, `XMLHttpRequest.DONE` 혹은 각 `0`, `1`, `2`, `3`, `4` 이다.
    - `responseText` : 서버가 응답으로 반환한 응답 본문인 문자열. 그 어떤 경우에도 해당 속성은 문자열(`string`)임에 유의. (단, 응답 본문이 없어서 `null` 일 경우는 제외)
    - `status` : 해당 객체의 HTTP 상태 코드. 해당 객체의 `readyState` 속성 값이 `HEADERS_RECEIVED`(`2`) 이상일 때에만 접근한다.
    - `200` : `OK` - 정상 상태.(주로 `200` 이상 `300` 미만의 값을 정상 상태로 간주한다.)
    - `400` : `Bad Request` - 서버가 요구하고 있는 데이터를 클라이언트가 누락하였거나 그 데이터의 형태가 잘못되었음을 의미한다.
    - `401` : `Unauthorized` - 주로 익명의 클라이언트가 해당 리소스에 접근할 권한이 없을때 사용된다.
    - `403` : `Forbidden` - 신원 확인이 완료된 클라이언트가 해당 리소스에 접근할 권한이 없을때 사용된다.
    - `404` : `Not Found` - 클라이언트가 요청한 리소스가 서버에 존재하지 않음을 의미한다.
    - `405` : `Method Not Allowed` - 클라이언트가 요청한 리소스에 대한 주소는 존재하지만, 해당 요청 방식을 허용하지 않음을 의미한다.
    - `500` : `Internal Server Error` - 요청을 처리하는 도중 서버 내부에서 오류가 발생하였음을 의미한다.

- 객체 함수
    - `open(m, u)` : 요청을 보낼 준비를 하기 위해 호출한다. 요청을 보낼 방식(Method)인 문자열을 `m`, 주소인 문자열 혹은 `URL` 객체를 `u` 에 전달한다.
        - 요청방식
            - `GET` : 일반적인 웹 브라우저의 주소창에 주소를 입력하고 요청을 보낼때 사용하는 방식이다. 데이터를 요청 주소에만 실어보낼 수 있고 일번적인 웹 페이지에 대한 응답을 위한 요청이나,
              데이터베이스 상에서 `SELECT` 쿼리가 발생하는 경우 사용하는 요청방식이다.
            - `POST` : 주로 데이터베이스 상에서 `INSERT` 쿼리가 발생하는 경우 사용하는 요청 방식이다. 단, `SELECT` 만 발생하더라도 전송하는 데이터가 주소상에 노출되어서는 안 되는
              경우, `POST` 방식을 사용하기도 한다.
            - `DELETE` : 주로 데이터베이스 상에서 `DELETE` 쿼리가 발생하는 경우 사용하느 요청 방식이다.
            - `PATCH` : 주로 데이터베이스 상에서 `UPDATE` 쿼리가 발생하는 경우 사용하는 요청방식이다. 요청 본문(Request Body)에 언급된 데이터만 수정된다. (레코드 일부)
            - `PUT` : 주로 데이터베이스 상에서 `PUT` 쿼리가 발생하는 경우 사용하는 요청방식이다. 요청 본문(Request Body)에 언급되지 않은 데이터도 수정된다. (레코드 전체)

- 객체 이벤트
    - `readystatechange` : 해당 객체의 `readyState` 속성 값이 변할때마다 실행할 이벤트
