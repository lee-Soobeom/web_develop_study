# javascript

## js

* js(javascript)는 html 언어로 작성된 페이지에 이벤트 등 동작과 연산을 적용하기 위해 사용한다.

## 적용 방법

* js를 적용하는 방법은 몇 가지가 있는데 다음과 같다.

- 스크립트 태그를 활용한 인라인 코드 작성
    - html 문서에 있는 head 혹은 body 태그의 자식이 될 수 있도록 script 태그를 만들어 해당 태그의 내부 내용에 js 문법을 작성하는 방법을 의미한다.
    - html 문서 내에 html 문법과 js 문법이 공존하게 됨으로 코드를 찾기 힘들어지고 유지보수가 까다로워진다.

* 이벤트 기반 속성 활용

- 코드를 적용하고자하는 태그에 onclick, onmouseover 등과 같은 이벤트 기반의 속성을 부여하는 방법을 의미한다.
- html 문서 내에 html 문법과 js 문법이 공존하게 됨으로 원하는 코드를 찾기 힘들어지고 유지보수가 까다로워진다.

* 스크립트 태그를 활용한 외부 자바스크립트 파일 로드

- 아래와 같이 head 태그의 자식이 되도록 script 태그를 작성하여 html 파일 외부 에서 작성된 js 파일을 불러와 사용할 수 있다.

>       <script src="..."></script>
> - src : 불러올 js파일의 주소 및 경로
> - 외부 js 파일을 로드할 때에는 script 태그의 내부 내용을 비워둔다.

# 변수

- 변수(Variable)는 선언(Declaration) 및 값 초기화 (initialization) 이후 값이 변할 수 있는 것을 의미한다.
- 변수 선언시 별도의 자료형(타입)을 명시하지 않고, 명명법으로 카멜 케이스를 사용한다.
- 동일한 스코프(Scope)에서 사용중인 이름이나 약속된 키워드를 변수의 이름으로 사용할 수 없다.
- 변수 선언시 값을 부여(Assign) 하지 않으면 초기 값으로 undefined 가 할당된다.
- 변수는 let 키워드를 사용하여 다음과 같이 선언할 수 있다.
    - let[변수 이름];
        - 위 처럼 값 초기화 없이 변수를 선언할 경우 그 값은 undefined 로 초기화 된다.
        - 아래와 같은 방식으로 변수 선언과 값이 초기 값을 할당할 수 있다.
        - let[변수 이름]=[값];

# 상수

- 상수 (Constant)는 선언 및 초기화 이후 값이 변하지 않는 것을 의미한다.
- 상수 선언시 별도의 자료형(타입)을 명시하지 않고, 명명법으로 카멜 케이스를 사용한다.
- 동일한 스코프(Scope)에서 사용중인 이름이나 약속된 키워드를 상수의 이름으로 사용할 수 없다.
- 상수는 선언시 값을 반드시 부여하여야 한다.
- 상수 선언 및 값 초기화
    - const [상수 이름] = [값];

# 자료형

## 문자열

- 문자열 자료형을 표현하기 위해서 홀따옴표(') 혹은 쌍따옴표(")혹은 백틱(')을 사용한다.
- html과의 연동이 많은 자바스크립트 특성상 쌍따옴표를 많이 사용하는 html을 위하여 문자열 표현시 쌍따옴표를 많이 사용하지 않고 홀따옴표를 많이 사용한다.
- 백틱을 사용한 문자열 표현식(${})을 활용하여 문자열 사이에 외부 변수나 상수를 삽입하기 쉽고, 문자열 이어붙이기가 필요 없어 편리하다.

## 숫자

- 별도의 특수문자를 사용하지 않으며 자바스크립트의 숫자는 정수와 실수를 별도로 구분하지 않는다.

## 논리값

- 별도의 특수문자를 사용하지 않으며 참 ( true )과 거짓( false ) 으로 이루어져있다.

## 널리쉬(Nullish)

- 널리쉬(Nullish)는 null 과 undefined 를 포함한다.
- null 은 스택 영역의 null 라는 값을 가지고 있으며, 힙에는 빈 값을 참조하고 있다.
- undefined 는 스택 영역에 undefined 라는 값을 가지고 있으며, 힙에는 아무 값도 할당되어 있지 않다.
- null 과 undefined 는 유사하나 null 이 보다 의도적인 의미를 가진다.
- typeof null 은 object 임에 유의한다.
- typeof undefined 는 undefined 임에 유의한다.
- 어떠한 널리쉬 값에 대해 null 을 피연산자 동등( == )비교시 참( true )이 연산됨을 활용할 수 있다.
    - null == undefined 는 참( true )이다.

## 배열 (중요)

- 배열(Array)은 하나의 변수가 여러개의 값을 가질 수 있도록 하기위해 사용한다.
- 배열의 작성 형태는 JSON(javaScript Object Notation)Array의 형태와 유사하다.
- 배열은 대괄호 ([.])로 인자(들)를 감싸고, 각 인자는 쉼표(,)로 구분할 수 있다.
- 배열이 가지는 인자는 인덱스(순번)를 가지고, 해당 인덱스는 반드시 0 번부터 시작하며, 배열에 대괄호([,])인자 접근 연산자를 사용하여 각 인자에 접근할 수 있다.
    - let [변수 이름]=([인자,...]);

    * 위와 같이 대괄호([,])로 인자(들)를 감싸고, 각 인자는 쉼표(,)로 구분할 수 있다.
    * 가령, 'Apple' , 'Banana' , 'Orange' 라는 세 개의 문자열을 인자로 가지는 fruits 라는 배열은 아래와 같이 만들 수 있다.
        - let fruits = ['Apple', 'Banana', 'Orange'];
    * 배열기 가지는 인자는 인덱스를 가지는데, 첫번째 인자인 'Apple' 부터 0번이며, 순차적으로 1 씩 증가한다.
    * 아래와 같이 배열에 인자 접근 연산자([,])와 인덱스를 통해 각 인자에 접근할 수 있다.
        - console.log(fruits[0});//Apple
        - console.log(fruits[2});//Orange
    * 추가로, 인자 접근시 음수나 범위를 벗어난 값을 전달할 경우 undefined 가 된다.
        - console.log(fruits[-1]);//undefined
        - console.log(fruits[3]);//undefined

## 객체 속성

- length : 배열이 가지고 있는 인자의 개수이다.

## 객체 함수

- at(x) :호출 대상인 배열이 가지고 있는 인덱스가 x 인 인자를 반환한다.
- concat(x) :호출 대상인 배열과 인자인 배열 x 를 이어 붙인 새로운 배열을 반환한다.
- fill(...)
    - fill(x) :호출 대상인 배열이 가지고 있는 모든 인자를 x 로 대체한다.
    - fill(x, f) :호출 대상인 배열이 가지고 있는 인자들 중 인덱스가 f 이상인 인자를 x 로 대체한다.
    - fill(x, f, t) :호출 대상인 배열이 가지고 있는 인자들 중 인덱스가 f 이상이고 t 미만인 인자를 x 로 대체한다.
- includes(x) :호출 대상인 배열이 가지고 있는 인자 중 그 값이 x 와 일치하는 인자가 존재하는가의 여부를 반환한다.
- indexOf(x) :호출 대상인 배열이 가지고 있는 인자 중 그값이 x 와 일치하는 가장 빠른 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1을 반환한다.
- lastIndexOf(x) :호출 대상인 배열이 가지고 있는 인자 중 그 값이 x 와 일치하는 가장 마지막 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1 을 반환한다.
- join(...)
    - join() :호출 대상인 배열이 가지고 있는 인자를 쉼표(,)로 이어붙인 문자열을 반환한다.
    - join(x) :호출 대상인 배열이 가지고 있는 인자를 x 로 이어붙인 문자열을 반환한다.
- pop() :호출 대상인 배열이 가지고 있는 인자 중 마지막 인자를 배열에서 제거하고 이를 반환한다.
- push(x) :호출 대상인 배열의 끝에 새로운 인자 x 를 추가하고 배열의 길이( length) 를 반환한다.
- reverse() :호출 대상인 배열이 가지고 있는 인자의 순서를 뒤집는다.
- shift() : 호출 대상인 배열이 가지고 있는 인자 중 첫번째 인자를 배열에서 제거하고 이를 반환한다.
- slice(...) *본체와 다른 객체
    - slice() :호출 대상이 배열이 가지고 있는 인자를 그대로 가지는 배열을 복사하여 반환한다.
    - slice(f) :호출 대상인 배열이 가지고 있는 인자 중 인덱스가 f 이상인 인자를 가지는 배열을 복사하여 반환한다.
    - slice(f, t) :호출 대상인 배열이 가지고 있는 인자 중 인덱스가 f 이상, t 미만인 인자를 가지는 배열을 복사하여 반환한다.
- splice(...)
    - splice(i, d) :호출 대상이 되는 배열이 가지고 있는 인자 중 그 인덱스가 i 인것부터 d 개를 제거하여 반환한다.
    - splice(i, d, ...v) :호출 대상이 되는 배열이 가지고 있는 인자 중 그 인덱스가 i 인것 부터 d 개를 제거하여 제거된 인자를 배열로 반환하고, 가변인자 v 의 첫번째 인자의 인덱스가 i 가
      될 수 있도록 추가한다.
    - 예시
    ```
    let days = ['일','월','가','나','금','토']; 
    undefined
    days.splice(2,2,'화','수','목');
    (2) ['가', '나']
    days;
    (7) ['일', '월', '화', '수', '목', '금', '토']
    ```

## 함수를 인자로 가지는 함수

- every(f(x?,i?,a?)) :호출 대상이 되는 배열이 가지고 있는 모든 인자가 전달된 함수 f 의 전달 인자 x 로 전달되었을 때 함수 f 가 참(true)을 반환하는가의 여부를 반환한다. 함수 호출시
  전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    - 예시
    ```
    let nums = [1, 5, 3 ,7 ,11];
    undefined
    nums
    (5) [1, 5, 3, 7, 11]
    nums.every( (x) => x > 0 );
    true 
    ```
- filter(f(x?, i? , a?)) :호출 대상이 되는 배열이 가지고 있는 인다 중 함수 f 의 전달 인자로 참 (true) 을 반환하는 인자만을 인자로 가지는 새로운 배열을 반환한다. 이를 만족하는
  인자가 없다면 반 배열([])을 반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    - 예시
    ```
    let nums = [-1, 13, 6 ,2 ,10 ,-13, 9, 4];
    undefined
    let evens = nums.filter((x) => x % 2 === 0);
    undefined
    evens;
    (4) [6, 2, 10, 4]
    ```
- find(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참 (true)을 반환하는 첫번째 인자를 반환한다. 그러한 인자가 없다면 undefined 를
  반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i: 순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    - 예시
    ```
    let nums = [-1, 13, 6 ,2 ,10 ,-13, 9, 4];
    undefined
    nums.find((x) => x % 2 === 0);
    6
    ```
- findLast(f(x?, i? ,a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 마지막 인자를 반환한다. 그러한 인자가 없다면 undefined
  를 반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
- findIndex(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 첫번째 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1
  을 반환한다. 함수 호출시 전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    ```
    let nums = [-1, 13, 6 ,2 ,10 ,-13, 9, 4];
    undefined
    nums.find((x) => x > 5);
    13
    nums.findIndex((x) => x > 5);
    1
    nums.findLast((x) => x > 5);
    9
    nums. findLastIndex((x) => x > 5);
    6
    ```
- forEach(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 전체에 대해 함수 f 의 전달 인자로 해당 함수를 단순 반복 실행한다.
  let fruits = ['Apple', 'Banana', 'Orange','Pineapple', 'Melon'];
  undefined
  fruits.forEach((x) => { console.log(` ${x}은/는 맛잇다.`);});
  VM4219:1 Apple은/는 맛잇다.
  VM4219:1 Banana은/는 맛잇다.
  VM4219:1 Orange은/는 맛잇다.
  VM4219:1 Pineapple은/는 맛잇다.
  VM4219:1 Melon은/는 맛잇다.
  undefined
- map(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 각 인자에 대해 함수 f 의 전달 인자로 반환되는 값으로 치환되는 인자를 각 인자로 가지는 새로운 배열을 반환한다. 함수 호출 시
  전달되는 인자는 순서대로 아래와 같고 선택적으로 사용할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    ``` 
    let fruits = ['Apple', 'Banana', 'Orange'];
    undefined
    fruits.map((x) => x.length);
    (3) [5, 6, 6]
    fruits.map((x) => x.toUpperCase());
    (3) ['APPLE', 'BANANA', 'ORANGE']; 
    ```
- some(f(x?, i?, a?)) :호출 대상이 되는 배열이 가지고 있는 인자 중 하나라도 함수 f 의 전달 인자로 참(true)을 반환하는가의 여부를 반환한다. 함수 호출시 전달되는 인자는 순새대로
  아래와 같고 선택적으로 사용 할 수 있다.
    - x:순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i:순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a:호출 대상인 배열
    ```
    let fruits = ['Apple', 'Banana', 'Orange']
    undefined
    fruits.every((x) => x.length === 5);
    false
    fruits.some((x) => x.length === 5);
    true
    ```
- sort(...)
    - sort() :호출 대상이 되는 배열이 가지고 있는 인자가 가지고 있는 값을 문자열 변환하였을 때 가지게되는 유니코드 값을 기준으로 정렬한다.
    - sort(f(a,b)) :호출 대상이 되는 배열이 가지고 있는 인접한 인자들을 각각 a 와 b 라고 하였을때, 비교 함수(Compare Function) f 가 반환하는 값이 0 보다 작을 경우
      a를 b보다 선행하도록(낮은 인덱스)배치한다. 0일 경우 a 와 b 의 배치를 변경하지 않는다. 0 보다 클 경우 b 를 a 보다 선행 하도록 배치한다.
    - 예시
    ```
    let nums = [13, 8, 2, 9 ,5];
     undefined
    nums.sort();
    (5) [13, 2, 5, 8, 9]
    let fruits = ['Apple', 'Banana', 'Orange','Pineapple', 'Melon'];
    undefined
    fruits.sort();
    (5) ['Apple', 'Banana', 'Melon', 'Orange', 'Pineapple']
    let nums = [13,8,2,9,5];
    undefined
    nums.sort((a,b) => a-b);
    (5) [2, 5, 8, 9, 13]
    ```
- reduce(f(c?, x?, i?, a?),s? :호출 대상이 되는 배열이 가지고 있는 인자를 반복하여 누산된 값을 반환한다.
    - c :반복하고 있는 누산기(Accumulator)
    - x :순차적으로 반복할 호출 대상인 배열이 가지는 인자
    - i :순차적으로 반복할 호출 대상인 배열이 가지는 인자의 인덱스
    - a :호출 대상인 배열
    - s :반복할 누산기(c)의 초기값
    - 예시
    ``` 
    let nums = [13, 8, 2, 9 ,5];
    undefined
    nums.reduce((c,x) => c + x,0)
    37
    ```
## 오브젝트

- 오브젝트(Object)는 키(Key)와 값(Value)으로 이루어진 쌍(Pair)의 집합을 가지는 객체이다.
- 오브젝트의 작성 형태는 JSON(JavaScript Object Notation)Object의 형태와 유사하다.
- 오브젝트는 중괄호({.})로 각 쌍들을 감싸고, 그러한 쌍들이 가지는 키와 값은 콜론(:)으로 구분하며, 하나의 오브젝트는 여러개의 쌍을 쉼표(,)로 구분하여 가질 수 있다.
- 오브젝트가 가지는 쌍들에는 순서가 없음으로 인덱스를 통한 접근이 불가능하다.(인덱스 개념이 없음)
- 오브젝트의 쌍이 가지고 있는 값에는 키를 통해 접근할 수 있고, 하나의 오브젝트가 가지는 동일한 계층의 키는 고유해야한다.
- 오브젝트가 가지는 키는 반드시 문자열이어야 하고 값의 타입에는 제한이 없다.
- 오브젝트의 작성은 아래와 같은 형태로 한다.
    - let [이름] = {
      [키 1]: [값 1],
      [키 2]: [값 2],
      ...
      };
    - 가령, 국가 코드별 한국어 이름을 가지는 오브젝트의 구조는 아래와 같이 작성할 수 있다.
    - 예시
    ```  
    let countryMap = {
    KR:'대한민국',
    US:'미국',
    JP:'일본',
    DE:'독일',
    FR:'프랑스'
    };  
    ```
    - 키 이름을 통해 쌍이 가지는 값에 접근하기 위해서는 오브젝트에 대괄호([,])혹은 멤버 접근(.)연산자를 사용할 수 있다.
    - console.log( countryMap.KR);//대한민국
    - console.log( countryMap['KR']);//대한민국
    - console.log( countryMap['RU']);//undefined
    - 멤버 접근(.)을 통해 접근할 때에는 키 이름을 문자열로 취급하여서는 안 된다.
    - 대괄호([,])를 통해 접근할 때에는 키 이름을 문자열로 취급하여야 한다.
    - 예시
    ```
    let countryMap = {
    KR:'대한민국',
    US:'미국',
    JP:'일본',
    DE:'독일',
    FR:'프랑스' };
    undefined
    countryMap['KR']
    '대한민국'
    let key='JP';
    undefined
    countryMap['key']
    undefined
    countryMap[key]
    '일본'
    ```
## 쌍 추가 및 값 변경

- 오브젝트에 이미 존재하는 쌍의 값을 변경하거나, 존재하지 않는 쌍을 추가하기 위해 아래와 같이 작성할 수 있다.
- [오브젝트].[키]=[값];
- [오브젝트][[키 문자열]]=[값];
- 예시
``` 
countryMap['UE']='영국'
'영국'
countryMap;
{KR: '대한민국', US: '미국', JP: '일본', DE: '독일', FR: '프랑스', …}
DE "독일"
FR "프랑스"
JP "일본"
KR "대한민국"
UE "영국"
US "미국"
```

## 쌍 삭제

- 존재하는 쌍을 삭제하기 위해 아래와 같이 작성할 수 있다.
- delete [오브젝트].[키];
- delete [오브젝트][[키 문자열]];
- 예시
``` 
let countryMap = {
KR:'대한민국',
US:'미국',
JP:'일본',
DE:'독일',
FR:'프랑스' };
undefined
delete countryMap['Jp'];
true
countryMap
{KR: '대한민국', US: '미국', JP: '일본', DE: '독일', FR: '프랑스'}
```

## 정적 함수

- 오브젝트의 정적인 함수는 Object 를 통해 접근한다.
- keys(x): 전달받은 오브젝트 x 가 가지는 키들을 인자로 가지는 1차원 배열을 반환한다.
- values(x):전달받은 오브젝트 x 가 가지는 값들을 인자로 가지는 1차원 배열을 반환한다.
- 예시
```
let countryMap = {
KR:'대한민국',
US:'미국',
JP:'일본',
DE:'독일',
FR:'프랑스' };
undefined
Object.keys(countryMap)
(5) ['KR', 'US', 'JP', 'DE', 'FR']
Object.values(countryMap);
(5) ['대한민국', '미국', '일본', '독일', '프랑스']
Object.keys(countryMap).every((x) => x.length===2)
true
Object.values(countryMap).sort();
(5) ['대한민국', '독일', '미국', '일본', '프랑스']
```

# 카멜 케이스(Camel case)

- **카멜 케이스(Camel case)**는 띄어쓰기를 하지 않고 각 단어의 첫 글자를 대문자로 붙여 쓰되, 전체 단어의 첫 글자는 대문자 또는 소문자로 쓸 수 있는 방식입니다. 이 형식의 이름은 대문자가 낙타
  등의 혹처럼 보이는 데에서 유래했습니다. 읽는 사람이 형상을 쉽게 떠올릴 수 있도록 "camelCase"로 표현하기도 합니다.
- 카멜 케이스는 변수 이름 지정 규칙으로 자주 사용됩니다. 다음의 변수는 모두 카멜 케이스로 작성된 예시입니다. console, encodeURIComponent, ArrayBuffer, HTMLElement.
- URI, HTML과 같이 구문에 약어가 포함된 경우, 카멜 케이스는 다양하게 표현될 수 있습니다. 어떤 사람들은 encodeURIComponent와 같이 약어를 모두 대문자로 표기하는 것을 선호합니다. 이는
  XMLHTTPRequest와 같이 약어가 연속될 경우 모호함을 줄 수 있습니다. 반면 XmlHttpRequest와 같이 약어의 첫 글자만 대문자로 표기하는 것을 선호하는 사람들도 있습니다. 실제 전역 변수인
  XMLHttpRequest는 두 방식을 혼합하여 사용합니다.
- 전체 구문의 첫 글자가 대문자인 경우, 이를 대문자 카멜 케이스 또는 *파스칼 케이스(Pascal case)*라고 합니다. 그렇지 않으면 소문자 카멜 케이스라고 합니다.
- 카멜 케이스는 JavaScript, Java 및 다양한 언어에서 가장 인기 있는 규칙입니다.

# 케밥 케이스(Kebab case)

- **케밥 케이스(Kebab case)**는 띄어쓰기 대신 하이픈 -을 사용하며, 모든 단어를 대체로 소문자로 작성하는 방식입니다. 이 형식은 케밥 꼬치에 고기가 꽂혀 있는 모습과 비슷하여 이와 같은 이름이
  붙여졌습니다. 읽는 사람이 형상을 쉽게 떠올릴 수 있도록 "kebab-case"로 표현되기도 합니다.
- 케밥 케이스(Kebab case)는 변수 이름 지정 규칙으로 자주 사용됩니다. 그러나 많은 언어에서 하이픈은 뺄셈을 나타내므로 케밥 케이스를 사용할 수 없습니다. CSS 속성인 background-color와
  font-family, HTML 속성인 aria-label,data-*는 케밥 케이스로 작성된 것입니다.
- 케밥 케이스로 작성된 단어는 종종 하이픈으로 연결된 단어로 간주됩니다.

## 연산자

### 할당 연산자

- 일반 할당 (`=`): `x = y` 꼴에서 `y` 를 `x` 에 할당한다.

> let x = 5;   
> x = 3;
>
> console.log(x); //3

- 더하기 복합 대입 연산 (`+=`) : `x += y` 꼴에서 `x` 와 `y` 를 합을 `x` 에 재할당한다.
- 빼기 복합 대입 연산 (`-=`) : `x -= y` 꼴에서 `x` 와 `y` 의 차를 `x` 에 재할당한다.
- 곱하기 복합 대입 연산 (`*=`) : `x *= y` 꼴에서 `x` 와 `y` 의 곱을 `x` 에 재할당한다.
- 나누기 복합 대입 연산 (`/=`) : `x /= y` 꼴에서 `x` 를 `y` 로 나눈 몫을 `x` 에 재할당한다.
- 나머지 복합 대입 연산 (`%=`) : `x %= y` 꼴에서 `x` 를 `y` 로 나눈 나머지를 `x` 에 재할당한다.
- 거듭 제곱 복합 대입 연산 (`**=`) : `x **= y` 꼴에서 `x` 의 `y` 제곱을 `x` 에 재할당한다.
- 논리 AND 복합 대입 연산 (`&&=`) : `x &&= y` 꼴에서 `x` 와 `y` 가 모두 참인가의 여부를 `x` 에 재할당한다.
- 논리 OR 복합 대입 연산 (`||=`) : `x ||= y` 꼴에서 `x` 와 `y` 중 하나가 참인가의 여부를 `x`에 재할당한다.
- 널리쉬 병합 복합 대입 연산 (`??=`) : `x ??= y` 꼴에서 `x` 가 널리쉬인 경우 `y` 값을, 아니라면 `x` 값을 재할당한다.

### 비교 연산자

- 동등 (`==`) : `x == y` 꼴에서 `x` 와 `y` 의 값이 같은가의 여부이다. 단, 다른 타입의 피연산자간의 비교를 시도한다.
- 부등 (`!=`) : `x != y` 꼴에서 `x` 와 `y` 의 값이 다른가의 여부이다. 단, 다른 타입의 피연산자간의 비교를 시도한다.
- 일치 (`===`) : `x == y` 꼴에서 `x` 와 `y` 의 값과 타입이 같은가의 여부이다.
- 불일치 (`!==`) : `x !== y` 꼴에서 `x` 와 `y` 의 값 혹은 타입 중 하나 혹은 모두가 다른가의 여부이다.
- 초과 (`>`) : `x > y` 꼴에서 `x` 가 `y` 보다 큰가의 여부이다.
- 미만 (`<`) : `x < y` 꼴에서 `x` 가 `y` 보다 작은가의 여부이다.
- 이상 (`>=`) : `x >= y` 꼴에서 `x` 가 `y` 보다 크거나 같은가의 여부이다.
- 이하 (`<=`) : `x <= y` 꼴에서 `x` 가 `y` 보다 작거나 같은가의 여부이다.
- return boolean : true or false

### 산술 연산자

- 더하기 (`+`) : `x + y` 꼴에서 `x` 와 `y` 의 합이다.
    - 피연산자중 하나 이상이 문자열일 경우 문자열 합치기를 수행한다.
- 빼기 (`-`) : `x - y` 꼴에서 `x` 와 `y` 의 차이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다. (NaN : Not a Number)
- 곱하기 : (`*`) : `x * y` 꼴에서 `x` 와 `y` 의 곱이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다.
- 나누기 (`/`) : `x / y` 꼴에서 `x` 를 `y` 로 나눈 몫이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다.
    - `y` 가 `0` 일 경우 그 결과는 `Infinity` 혹은 `-Infinity` 이다.
- 나머지 (`%`) : `x % y` 꼴에서 `x` 를 `y` 로 나눈 나머지이다.
    - 피연산자중 그 타입이 `number`가 아닌것이 있을 경우 `number` 로의 형 변환을 시도한 후 연산한다.
    - `number` 로의 형변환이 불가능한 피연산자가 있을 경우 연산 결과는 `NaN`이다.
    - `y` 가 `0` 일 경우 `NaN` 이다.
- 거듭제곱 (`**`) : `x ** y` 꼴에서 `x` 의 `y` 제곱 (`x`<sup>`y`</sup>)
- 단항 양수 (`+i`) : `+x` 꼴에서 변수 `x` 의 부호를 강조하거나, `x`의 타입이 `number`가 아닐때 `number` 로의 형변환을 시도하게 한다.
- 단한 음수 (`-i`) : `-x` 꼴에서 변수 `x` 의 부호를 반전하거나, `x`의 타입이 `number`가 아닐때 `number` 로의 형변환을 시도하게 한다.
- 증가 (`++`)
    - 전위 증가 : `++x` 꼴에서 구문 실행 전 `x` 에 `1`을 더한다.
    - 후위 증가 : `x++` 꼴에서 구문 실행 후 `x` 에 `1`을 더한다.
- 감소 (`--`)
    - 전위 감소 : `--x` 꼴에서 구문 실행 전 `x` 에 `1` 을 뺀다.
    - 후위 감소 : `x--` 꼴에서 구문 실행 후 `x` 에 `1` 을 뺀다.

> let x = 5;   
> console.log(x + 5); //6   
> console.log(x); //5
>
> console.log(++x); //6   
> console.log(x) //6  
> let y = 5;
>
> console.log(y--); //5   
> console.log(y); //4

### 논리 연산자

- 논리 AND (`&&`) : `x && y` 꼴에서 `x` 와 `y` 가 모두 참(`true`) 인가의 여부이다.
- 논리 OR (`||`) : `x || y` 꼴에서 `x` 와 `y` 중 하나가 참(`true`) 인가의 여부이다. (선행 조건문(x)이 참이면 후행 조건문(y)을 검사하지 않는다.)
- 논리 NOT,부정 (`!`) : `!x` 꼴에서 `x` 의 논리를 부정(반전)한다.

### 삼항 연산자

- 삼항 연상자 (`? :`) : `c ? t : f` 꼴에서 논리 `c` 가 참(`true`) 이라면 `t` 로 , 거짓(`false`) 이라면 `f` 로 연산된다.

> age > 19 ? '성인' : '미성년자'   
> (논리)  ?  (참) :  (거짓)

### 기타 연산자

- 멤버 접근(`.`) : `x.y` 꼴에서 `x` 의 멤버인 `y` 에 접근하기 위해 사용한다.
- 배열 인자 접근(`[]`) : `x[y]` 꼴에서 배열인 `x` 의 인자 중 인덱스가 `y` 인 인자에 접근하기 위해 사용한다.
- 오브젝트 속성 접근(`[]`) : `x[y]` 꼴에서 오브젝트인 `x` 의 쌍 중 키가 `y` 인 쌍에 접근하기 위해 사용한다.
- 객체화(`new`) : `new T` 꼴에서 타입 `T` 를 객체화하기 위해 사용한다.
- 함수 호출(`()`) : `f()` 꼴에서 함수 `f` 를 호출하기 위해 사용한다.
- 우선 연산(`()`) : `(x)` 꼴에서 연산 `x` 를 우선하기 위해 사용한다.
- 삭제 (`delete`) : `delete x.y` 혹은 `delete x['y']` 꼴에서 오브젝트 `x` 의 속성인 `y`를 삭제하기 위해 사용한다.
- `isntanceof` : `x instanceof T` 꼴에서 객체 `x` 가 타입 `T` 이거나 상속, 구현 대상인가의 여부이다.
- `typeof` : `typeof x` 꼴에서 `x` 의 타입인 문자열이다.
- 널리쉬 병합 연산자 (`??`) : `x ?? y` 꼴에서 `x` 가 널리쉬 일때 `y` 값으로 연산되고, 그렇지 않으면 `x` 그대로 연산된다. 할당하지 않는다.
- 옵셔널 체이닝 멤버 접근 연산자 (`?.`) : `x?.y` 꼴에서 `x` 의 멤버인 `y` 에 접근할 때 `x` 가 널리쉬라면, 오류를 발생시키는 대신, 전체 결과를 `undifined` 로 갈음한다.

> el?.value ?? '(없음)'   
> undefined ?? '(없음)'

### 연산자 우선순위

- 연산자 사이에는 연산되는 우선순위가 있으며 아래는 숫자가 작을수록 우선순위가 높다는 의미이다.

1. 우선 연산(`()`)
2. 멤버 접근, 옵셔널 체이닝 멤버 접근, 배열 인자 접근, 오브젝트 속성 접근(`.`, `?.`, `[]`, `[]`)
3. 객체화, 함수 호출(`new`, `()`)
4. 논리 NOT, 단항 양수, 단항 음수, `typeof`, `delete`(`!`, `+`, `-`)
5. 거듭 제곱(`**`)
6. 곱하기, 나누기, 나머지(`*`, `/`, `%`)
7. 더하기, 빼기 (`+`, `-`)
8. 초과, 미만, 이상 ,이하, `instanceof`(`>`, `<`, `>=`, `<=`)
9. 동등, 부등, 일치, 불일치(`==`, `!=`, `===`, `!==`)
10. 논리 AND(`&&`)
11. 논리 OR(`||`)
12. 널리쉬 병합 연산(`??`)
13. 삼항 연산(`? :`)
14. 일반 할당, 복합 대입 연산(`=` 등)

## 반복문

### 키워드

#### break

- `break` 키워드는 속해있는 반복문을 종료시키기 위해 사용한다.

#### continue

- `continue` 키워드는 현재 진행중인 사이클을 종료하고, 다음 사이클로 진행하기 위해 사용한다.

### for

- `for`반복문은 반복의 기준이 되는 변수(주로 인덱스)를 활용하여 특정 구현부를 반복하고자 할 때 사용한다.

>       for ([변수 선언 및 초기화]; [반복 조건]; [변수 가감 혹은 복합 대입]) {   
>           [구현부]   
>       }
> 1. `for`반복문을 위한 `변수선언` 및 `초기화`한다.
> 2. `반복 조건`이 참(`true`)인지 확인한다.
     >

- `반복 조건`이 참(`true`)이라면 `구현부`를 1회 실행하고, `3번`으로 이동한다.

> - `반복 조건`이 거짓(`false`)이라면, 반복문 실행을 종료한다.
> 3. 변수 가감 혹은 복합 대입을 실행하고 `2번`으로 돌아간다.

### for ... in

- `for ...in` 반복문은 문자열로 키가 지정된 열거 가능한 대상의 키를 반복하기 위해 사용한다.
- 반복 대상의 인자가 인덱스를 가지고 순서대로 나열되어 있는 경우 `for ...in` 을 사용하지 않는다.

>       for ([변수 혹은 상수 선언] in [반복 대상]) {   
>           [구현부]   
>       } 
> - 반복 대상은 주로 Object이다. for (const key in value) {}

### for ... of

- `for ...of` 반복문은 반복할 수 있는 대상이 가지는 인자에 대해 반복하기 위해 사용한다.
- **인덱스에 대한 변수가 필요 없을 경우** 인덱스 범위 오류 및 가독성 향상 등을 위해 가능한한 일반 `for` 반복문 보다 `for ...of` 반복문을 사용하는 것이 좋다.

>       for ([변수 혹은 상수 선언) of [반복대상]) {   
>           [구현부]   
>       }

### while

- `while` 반복문은 주어진 조건이 참(`true`)일때 횟수와 관계 없이 구현부를 실행하기 위해 사용한다.

>       while ([조건] {   
>           [구현부]   
>       }
> - 만약 `조건`이 항상 참(`true`)이거나, 거짓(`false`)으로 변하는 경우의 수가 없고, 구현부 내에 `break` 및 `return` 등의 중단 키워드가 없다면, 해당 반복문이 무한히 반복됨으로
    유의한다.

### do ... while

- `do ... while` 반목문은 `while` 반복문과 유사하나, 조건과 관계없이 최초 한번은 반드시 구현부를 실행한다는 차이점이 있다.

>       do { 
>           [구현부]   
>       } while ([조건]);
>
> - 만약 `조건`이 항상 참(`true`)이거나, 거짓(`false`)으로 변하는 경우의 수가 없고, 구현부 내에 `break` 및 `return` 등의 중단 키워드가 없다면, 해당 반복문이 무한히 반복됨으로
    유의한다.

## 조건문

### if

- 주어진 조건이 참일때만 구현부를 실행하기 위해 사용한다.

>       if ([조건]) {   
>           [구현부]   
>       }

### else

- `else` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else` 문은 앞서 제시된 모든 조건이 거짓일때 최종적으로 실행할 구현부를 위해 사용한다.
- `else` 문은 `if`문 하나에 여러개 존재할 수 없다.
- `else` 문은 `if`문의 마지막 구문이어야 한다.

>       if ([조건]) {   
>           [참 구현부]   
>       } else {   
>           [거짓 구현부]   
>       }

### else if

- `else if` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else if` 문은 앞서 제시된 모든 조건이 거짓일때 부수적인 조건을 추가하여 해당 조건이 참일때 구현부를 실행하기 위해 사용한다.
- `else if` 문은 `if` 문 하나에 여러개 존재할 수 있다.
- `else if` 문은 조건이 비록 참이라 하더라도 선행하는 `if` 혹은 `else if` 의 조건이 참이라면 해당 후행하는 `else if` 는 실행되지 않는다. (하나의 `if` 문에서 실행될 수 있는
  구현부는 하나 이하임으로)
- 모든 `else if` 는 `if` 보다 후행하고 `else` 보다 선행하여야 한다.

>       if ([선행 조건 1]) {   
>           [선행 조건 1 구현부]   
>       } else if ([선행 조건 2]) {   
>           [선행 조건 2 구현부]   
>       } else if ([선행 조건 3]) {   
>           [선행 조건 3 구현부]   
>       } else {   
>           [거짓 구현부]   
>       } 
> - 위 예시에서 `선행 조건 1` 이 참인 경우 `선행 조건 1 구현부` 를 실행하고 나머지 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 이 거짓이고 `선행 조건 2` 가 참인 경우 `선행 조건 2 구현부` 를 실행하고 후행하는 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 및 `선행 조건 2` 가 거짓이고 `선행 조건 3` 이 참인 경우 `선행 조건 3 구현부` 를 실행하고 후행하는 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1`, `선행 조건 2`, `선행 조건 3` 이 모두 거짓이라면 `else`를 실행한다.
> - 즉, `else if` 의 개수와 무관하게 하나의 `if` 문에 존재하는 구현부는 실행되지 않거나, 단 한 개만 실행될 수 있다.

### switch

- `switch` 문은 `분기 대상 변수` 가 가지는 값에 따라 `case` 를 활용하여 실행할 구문을 분리하기 위해 사용한다.

>       switch ([분기 대상 변수]) {   
>           case [값 1]:   
>               [값 1 구현부]   
>               [break;]?   
>           case [값 2]:   
>               [값 2 구현부]   
>               [break;]?  
>           [default:]?   
>               [default 구현부]?   
>       }
> - `분기 대상 변수` 가 가지는 값이 `case` 에 명시된 `값` 과 일치하는 가장빠른 `case` 의 구현부가 실행된다.
> - 일치하는 `case` 가 없다면 `default` 구현부가 실행된다.
> - `break` 키워드는 해당 위치에서 즉시 `switch` 문을 종료하겠다는 의미이다.
> - `default` 는 여러개 존재할 수 없으며 작성시 반드시 `switch` 의 마지막에 위치해야 한다.

- break 키워드가 없으면, 일치하는 케이스 포함한 아래의 모든 코드를 실행한다.

## 함수

- 함수(Function)는 호출(Call, Invoke)가능한 대상이다.
- 함수는 반복적으로 여러곳에서 사용될 가능성이 높은 로직을 분리하기 위해 사용한다.
- 하나의 함수는 하나의 목적을 가지는 로직을 구현하는 것이 좋다.
- 함수의 명명법은 카멜 케이스이고 주로 아래의 형태를 가진다.
    - `[동사]`
    - `[동사][목적어]`
    - `to[목적어]`

### 함수 호출

- 함수는 종류를 구분하지 않고 아래와 같이 호출할 수 있다.

>       [함수이름]([전달 인자, ...]?);   
> - 가령, `console` 의 멤버인 `log` 라는 이름을 가지느 함수에 전달 인자 `Hello World` 를 전달하여 호출하는 표현은 아래와 같다.
>
>
>       console.log('Hello World');   

## 일반 함수

### 기명 함수

- 기명 함수는 이름이 있는 함수로 아래와 같이 작성한다.

>       function [함수 이름] ([매개 변수, ...]?) {
>           [구현부]
>       }
> - 가령, 전달 받은 매개 변수 `a` 와 `b` 의 합을 반환하기 위한 함수 `sum` 은 아래와 같이 만들 수 있다.
>
>
>       function sum (a, b) {   
>           return a + b;   
>       }
> - `return` 키워드는 해당 함수의 호출 경과를 호출자에게 반환하기 위해 사용한다.
> - `return` 키워드는 해당 위치에서 해당 함수의 실행을 즉시 종료한다. 이에, 반환값 없이 해당 함수의 실행을 고의로 종료하기 위해 `return;` 만 작성하기도 한다.
> - 값이 반환하거나 (`return;`) 반환하지 않은 경우, 해당 함수의 호출 결과는 `undefined` 이다.
