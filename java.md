### 공통

### 서론

1. 자바(Java)언어는 컴파일시 바이트 코드가 되는 언어로, 개발자가 작성한 코드가 바이트 코드로 컴파일 되어 운영체제 커널(Kernel)이 이를 직접 읽어들이지 않고, JRE(Java Runtime
   Environment)가 해당 바이트코드를 읽어들여 그 결과인 바이너리 코드를 운영체제 커널이 이해할 수 있는 형태로 전달하는 방식을 채택하고 있다.
2. 이러한 방식 때문에, 각 운영체제에 맞는 JRE가 적절하게 구축되어 있다면 하나의 코드로 컴파일된 실행 파일로 운영체제와 무관하게 개발 및 실행할 수 있다는 장점이 있지만, 컴파일 결과가 즉시 바이너리
   코드로 변환되는 언어에 비해 속도가 느리다는 단점이 있다.

### JRE

- JRE(Java Runtime Environment)는 자바로 작성된 프로그램을 실행하기 위해 필요한 구성요소의 집합인 소프트웨어이다.

### JDK

- JDK(Java Development Kit)는 자바 언어로 프로그램을 개발하고 실행하기 위한 구성요소의 집합인 소프트웨어이다. 이는 JRE를 포함하고 있다.

### JVM

- JVM(Java Virtual Machine)는 자바로 개발된 프로그램을 실행하기 위해 구축된 가상의 환경을 의미한다.
- JRE 설치 후 실제로 자바로 작성된 프로그램을 구동하여 바이너리 코드로 변환하는 실행 환경이다.

### 진입점

- 프로그램이 실행되었을 때 가장 먼저 실행될 메서드이다.
- 진입점이되는 메서드는 하나의 프로그램 내에 하나만 있어야 한다.
- 자바에서 진입점은 아래와 같이 작성한다.

>       public static void main(String[] args) {
>           
>       }

### 정적

- 자바에서 정적(`static`)인 리소스는 프로그램이 실행되는 순간, 진입점(`main` 메서드)이 실행되기 전, 모두 선언된다.
- 반대로 비정적인(Non-static)인 리소스는 해당 리소스를 포함하는 구성요소가 객체화될 때 혹은 메서드가 실행될 때 선언된다.
- 정적인 리소스는 메모리 상에서 유일하다(단 하나만 존재). 이를 포함하는 구성 요소가 객체화 되더라도 정적인 대상은 제외된다.
- 따라서, 비정적인 대상이 정적인 대상에 접근하는 것은 항상 허용되지만, 정적인 대상이 비정적인 대상에 (객체화 없이)접근하는 것은 허용되지 않을 수 있다.

>       ▶(run)----------static resource----------main----------|

#### print

- 'sout' + tab >>> System.out.println : print + ln, 개행o
- System.out.print: 개행x

### 타입

- 타입(Type)은 어떠한 값을 담을 수 있는 형태(종류)이다. 크게 기초 타입과 참조 타입으로 나누어져 있다.

### 기초 타입

- 기초 타입(기본 타입, 원시 타입, Primitive Type)은 해당 타입의 변수 값이 리터럴(Literal)이고 메모리의 스택(Stack)영역에 값이 직접 할당되는 타입이다.
- 정수형
    - `byte`: (1 Byte) `-128` 이상 `127` 이하의 수
    - `short`: (2 Bytes) `-32,768` 이상 `32,767` 이하의 수
    - `int`: (4 Bytes) `-2,147,483,648` 이상 `2,147,483,647` 이하의 수
    - `long`: (8 Bytes) `-9,223,372,036,854,775,808` 이상 `9,223,372,036,854,775,807` 이하의 수. 리터럴 숫자 끝에 `L`을 붙임으로써 `long`
      타입의 숫자임을 명시적으로 표현할 수 있다.
    - 보다 작은 타입의 값을 보다 큰 타입에 할당하는 것은 가능하지만, 보다 큰 타입의 값을 보다 작은 타입에 할당하는 것은 허용되지 않는다.
    - 별도의 명시가 없는 정수 표기는 모두 `int` 타입으로 간주한다.
        - 단, `byte` 나 `short` 타입에 할당하기 위한 리터럴 정수는 묵시적으로 강제 형변환을 발생시킨다. 보다 상세한 조건은 아래와 같다.
        - `-128` 이상 `127` 이하의 정수 리터럴을 `byte`타입의 변수에 할당하는 경우
        - `-32,768` 이상 `32,767` 이하의 정수 리터럴을 `short`타입의 변수에 할당하는 경우
    - 강제 형변환을 통해 보다 큰 타입의 값을 보다 작은 타입의 변수에 할당할 경우 오버플로우/언더플로우가 발행할 수 있다.
- 실수형
    - `float`: (4 Bytes) `1.4E-45` 이상 `3.4E+38` 이하의 실수. 리터럴인 숫자 끝에 `F`를 붙임으로써 `float` 타입의 숫자임을 명시적으로 표시할 수 있다.
    - `double`: (8 Bytes) `4.9E-324` 이상 `1.79E+308` 이하의 실수. 리터럴인 숫자 끝에 `D`를 붙임으로써 `double` 타입의 숫자임을 명시적으로 표시할 수 있다.
    - 별도의 명시가 없는 실수 표기는 모두 `double` 타입으로 간주한다.
- 문자형
    - `char`: (2 Bytes) 문자 하나를 담기위해 사용하는 타입이다. 특수 문자 홀따옴표(`'`)를 사용한다. 역슬래쉬(`\`)를 활용하여 특수한 문자를 할당할 수 있다. 가령, 개행자는 `\n`이고,
      공란(빈값)은 `\0`와 같다. 문자형 타입의 값은 비어있을 수 없음(`''`)에 유의한다.
- 논리형
    - `boolean`: (1 Byte) 참(`true`)과 거짓(`false`)을 가진다.

>       [타입] [이름] = [값];
>       int i = 23;
>       long l = 2147483647L;
>       int c = (int) 13L; // 강제형변환
>       float = 3.14F;
>
>
>       char c = 'A'; // '\0', '\n', ... 
>       short s = c; // short: -32768~32767 & char: 0~65535
>       int asc = a; // ascii code table (int <> char)

### 참조 타입

- 참조 타입(레퍼런스 타입, Reference Type)은 해당 타입의 변수 값이 리터럴이지 않고(문자열 `Stritng` 제외), 메모리의 스택(Stack) 영역에는 힙(Heap)의 주소가, 힙 영역에는 실제
  값이 저장된다.
- 기초 타입을 제외한 나머지 모든 타입은 참조 타입이다.
- 참조 타입은 `new` 연산을 통해 객체화(Instantiation)하여 구현하고, 이 값을 객체라고 한다. 이 객체의 메모리 크기는 가변적이다.
- 대표적인 참조 타입으로 문자열(`String`)이 있다. 문자열은 객체화 과정(`new`)을 생략하고 쌍따옴표(`"`)특수기호를 통해 리터럴처럼 사용할 수 있도록 처리되어 있다.

### 변수

- 변수(Variable)는 타입과 이름을 가지고 타입에 부합하는값을할당하여 활용하기 위해 사용한다. 종류는 지역 변수와 멤버 변수, 매개 변수 등으로 나눌 수 있다.
- 메서드 내에서 변수를 선언할때 선언부가 속해있는 스코프 혹은 보다 상위 스코프에서 사용중인 이름을 다시 사용할 수 없다. 이는 매개변수를 포함한다.
- 변수 이름으로 예약된 키워드를 사용할 수 없다. (`for`, `int`, `public` 등)

### 지역 변수

- 지역 변수(Local Variable)는 메서드(Method)안에 존재하는 변수이다.
- 지역 변수에 값이 할당된 적이 없다면, 값 할당을 제외한 모든 접근이 제한된다.
- 명명법: 카멜 케이스
- 선언 방식은 아래와 같다.

>       [타입] [이름];
>
>
>   - 혹은 선언과 동시에 값을 초기화하기 위해 아래와 같이 작성할 수 있다.
>
>
>       [타입] [이름] = [값];

### 멤버 변수

- 멤버 변수(Member Variable)는 클래스나 인터페이스 등의 구성 요소가 직접 가지는 변수이다.
- 상수가 아닌 멤버 변수에 값을 할당한 적이 없다면, 자동으로 기본 값이 할당된다. **중요**
    - 정수 밑 실수 등 숫자 기초 타입: `0`
    - 문자 기초 타입: `\0`
    - 논리 기초 타입: `false`
    - 모든 기초 타입: `null`
- 상수인 멤버 변수의 값은 반드시 직접 할당하거나, 생성자를 통해 초기화하여야 한다.
- 명명법: 카멜 케이스

### 매개 변수

- 매개 변수(Parameter)는 메서드 호출시, 호출자가 전달해주는 인자(Argument)를 전달 받기 위해 사용하는 변수이다.

### 상수

- 명명법: 카멜 케이스
- 읽기 전용 변수는 편의상 상수라고 많이 부르며, `final` 키워드를 통해 변수의(스택) 값이 한번 할당된 이후로 변할 수 없음을 지정한다.
- `final` 키워드를 사용하였다 하더라도, 참조 타입의 객체가 가지는 힙 연역의 내용에 대한 불변성(Immutability)이 보장되는 것은 아님으로 엄밀히 말하면 상수(Constant)라고 말하면 안 되나,
  편의상 상수라고 많이 부른다.
- 정적인 상수(`static final`)이며 리터럴(모든 기초 타입 및 `String`)이거나 그 속성의 불변성을 보장하는 참조 타입인 멤버 변수에 한하여 대문자 스네이크 케이스 명명법을 사용한다.
- 매개변수에도 `final` 키워드 사용 가능하다.
- 선언 방식은 아래와 같다.

>       final [타입] [이름] = [값];
>
>
>   - 지역 변수는 상수로 지정하여도 값 초기화를 반드시 할 필요는 없기 때문에 아래와 같이 선언할 수 있다.
>
>
>       final [타입] [이름];
>
>
>   - 상수인 멤버 변수의 값은 반드시 직접 할당하거나, 생성자를 통해 초기화 하여야 한다.

### 연산자

### 할당 연산자

- 일반 할당(`=`): `x = y` 꼴에서 `x`에 `y`를 대입한다.
- 더하기 복합 대입 연산(`+=`): `x += y` 꼴에서 `x` 와  `y`를 더한 값을 `x`에 재할당한다.
- 빼기 복합 대입 연산(`-=`): `x -= y` 꼴에서 `x` 와 `y`를 뺀 값을 `x`에 재할당한다.
- 곱하기 복합 연산(`*=`): `x *= y` 꼴에서 `x` 와 `y`의 곱을 `x`에 재할당한다.
- 나누기 복합 연산(`/=`): `x /= y` 꼴에서 `x` 를 `y`로 나눈 몫을 `x`에 재할당한다.
- 나머지 복합 연산(`%=`): `x %= y` 꼴에서 `x` 를 `y`로 나눈 나머지를 `x`에 재할당한다.

### 비교 연산자

- 동등(`==`): `x == y` 꼴에서 `x` 와 `y`의 (스택) 값이 같은가의 여부이다.
- 부등(`!=`): `x != y` 꼴에서 `x` 와 `y`의 (스택) 값이 다른가의 여부이다.
- 초과(`>`): `x > y` 꼴에서 `x` 가 `y` 보다 큰가의 여부이다.
- 미만(`<`): `x < y` 꼴에서 `x` 가 `y` 보다 작은가의 여부이다.
- 이상(`>=`): `x >= y` 꼴에서 `x` 가 `y` 보다 크거나 같은가의 여부이다.
- 이하(`<=`): `x <= y` 꼴에서 `x` 가 `y` 보다 작거나 같은가의 여부이다.
- 초과, 미만, 이상, 이하 연산자의 피연산자는 그 두 피연산자의 타입이 같거나, 하나가 다른 하나의 타입으로 묵시적 형변환이 가능한 형태의 논리값(`boolean`)을 제외한 숫자이거나 이를 감싸는 참조 타입(
  `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double` 등)이어야 한다.
- 동등, 부등 연산자의 피연산자는 그 두 피연산자의 타입이 같거나 하나가 다른 하나의 타입으로 묵시적 형변환이 가능한 형태여야 한다.

### 산술 연산자

- 더하기(`+`): `x + y`꼴에서 `x`와 `y`의 합이다.
- 빼기(`-`): `x - y`꼴에서 `x`에서 `y`를 뺀 값이다.
- 곱하기(`*`): `x * y`꼴에서 `x`와 `y`의 곱이다.
- 나누기(`/`): `x / y`꼴에서 `x`를 `y`로 나눈 몫이다.
- 나머지(`%`): `x % y`꼴에서 `x`를 `y`로 나눈 나머지이다.
- 단항 양수(`+`): `+x`꼴에서 변수 `x`의 부호를 강조한다. 연산결과 타입은 `int`
- 단항 음수(`-`): `-x`꼴에서 변수 `x`가 가지는 값의 부호를 반전한다. 연산결과 타입은 `int`
- 증가(`++`)
    - 전위 증가: `++x`꼴에서 구문 실행 전 `x`에 `1`을 더한다.
    - 후위 증가: `x++`꼴에서 구문 실행 후 `x`에 `1`을 더한다.
- 감소(`--`)
    - 전위 감소: `--x`꼴에서 구문 실행 전 `x`에서 `1`을 뺀다.
    - 후위 감소: `x--`꼴에서 구문 실행 후 `x`에서 `1`을 뺀다.
- 숫자 타입(정수, 실수)간의 사칙 연산 결과는, 두 피연산자의 타입이 같다면, 반드시 동일 타입으로 연산된다. (10 / 3 >>> int 3, 100_000 * 100_000 >>> int overflow)
- 숫자 타입간의 사칙 연산 중, 두 피연산자의 타입이 다르다면, 보다 큰 타입으로 연산된다.
- 단, 사칙 연산의 두 피연산자 혹은 일부 산술 연산자의 피연산자의 타입이 `int` 미만의 정수 타입(`byte`, `short`)일 경우 그 연산 결과는 `int`이다.

>       byte a = 5;
>       final byte a0 = 5;
>       byte b = 5;
>       final byte b0 = 5;
>
>       byte c = a + b; // error
>       byte d = a0 + b0; // ok >>> a0, b0 값이 final 때문에 확정적이다.
>       byte e = -a; // error >>>  a가 -128일때(byte -128~127) overflow

### 논리 연산자

- 논리 AND(`&&`): `x && y` 꼴에서 `x`와 `y`가 모두 참(`true`)인가의 여부이다.
- 논리 OR(`||`): `x || y` 꼴에서 `x`와 `y`중 하나가 참(`true`)인가의 여부이다.
- 논리 NOT(`!`): `!` 꼴에서 `x`의 논리를 부정(반전)한다.

### 삼항 연산자

- 삼항 연산자(`? : `): `c ? t : f` 꼴에서 조건 `c`가 참(`true`)이라면 `t`, 거짓(`false`)이라면 `f`가 된다.

### 기타 연산자

- 멤버 접근(`.`): `x.y` 꼴에서 `x`의 멤버인 `y`에 접근하기 위해 사용한다.
- 배열 접근 인자(`[]`): `x[y]` 꼴에서 배열인 `x`의 인자 중 인덱스가 `y`인 인자에 접근하기 위해 사용한다.
- 객체화(`new`): `new T` 꼴에서 타입 `T`를 객체화하기 위해 사용한다.
- 메서드 호출(`()`): `f()` 꼴에서 메서드 `f`를 호출하기 위해 사용한다.
- 우선 연산(`()`): `(x)` 꼴에서 연산 `x`를 우선하기 위해 사용한다.
- 단항 형 변환(`(T)`): `(T) x` 꼴에서 `x`늬 타입을 강제로(명시적으로) `T`로 변환한다.
- 타입 비교(`instanceof`): `x instanceof T` 꼴에서 (기초 타입이 아닌)값 `x`가 (참조) 타입 `T`로 형변환될 수 있는가의 여부이다.

### 연산자 우선순위

1. 우선 연산, 메서드 호출, 배열 인자 접근, 멤버 접근 (`()`, `()`, `[]`, `.`)
2. 후위 증가, 후위 감소 (`++`, `--`)
3. 전위 증가, 전위 감소, 단항 양수, 단항 음수, 논리 NOT (`++`, `--`, `+`, `-`, `!`)
4. 객체화 (`new`)
5. 곱하기, 나누기, 나머지 (`=`, `/`, `%`)
6. 더하기, 빼기 (`+`, `-`)
7. 초과, 미만, 이상, 이하 타입 비교 (`>`, `<`, `>=`, `<=`, `instanceof`)
8. 동등, 부등 (`==`, `!=`)
9. 논리 AND (`&&`)
10. 논리 OR (`||`)
11. 삼항 연산자 (`? :`)
12. 할당, 복합 대입 연산 (`=`, `+=`, `-=`, `*=`, `/=`, `%=`)

### 반복문

### for

- `for` 반복문은 반복의 기준이되는 변수(주로 인덱스)를 활용하여 특정 구혅부를 반복 실행하고자 할 때 사용한다

>       for ([변수 선언 및 초기화]; [반복 조건]; [변수 가감 및 할당]) {
>           [구현부]
>       }
>
>
>       i. `for` 반복문을 위한 `변수 선언 및 초기화`를 실행한다.
>       ii. `반복 조건`이 참(`true`)인지 확인한다.
>           - `반복 조건`이 참(`true`)이라면 `구현부`를 1회 실행하고 `iii`로 이동한다.
>           - `반복 조건`이 거짓(`false`)이라면 `for` 반복문을 실행을 즉시 종료한다.
>       iii. 

### 향상된 for(Enhanced for)

- 향상된 for(Enhanced for) 반복문은 반복할 수 있는 대상이 가지는 인자에 대해 반복하기 위해 사용한다.
- 인덱스가 필요 없을 경우 인덱스 범위 오류를 최소화 및 가독성 향상 등을 위하여 가능한한 향상된 for 반복문을 사용하는 것이 좋다.

>       for ([변수 선언] : [반복 대상]) {
>           [구현부]
>       }

### while

- `while` 반복문은 주어진 조건이 참(`true`)일때 횟수와 관계없이 구현부를 실행하기 위해 사용한다.

>       while ([조건]) {
>           [구현부]
>       }
>
>
>    - 만약 `조건`이 항상 참(`true`)이거나 거짓(`false`)으로 변하는 경우의 수가 없다면, 혹은 `break` 혹은 `return` 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야한다.

### do ...while

- `do ...while` 반복문은 `while` 반복문과 유사하다.

>       do {
>           [구현부]
>       } while ([조건])
>
>
>    - 만약 `조건`이 항상 참(`true`)이거나 거짓(`false`)으로 변하는 경우의 수가 없다면, 혹은 `break` 혹은 `return` 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야한다.

## 조건문

### if

- 주어진 조건이 참일때만 구현부를 실행하기 위해 사용한다.

>       if ([조건]) {   
>           [구현부]   
>       }

### else

- `else` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else` 문은 앞서 제시된 모든 조건이 거짓일때 최종적으로 실행할 구현부를 위해 사용한다.
- `else` 문은 `if`문 하나에 여러개 존재할 수 없다.
- `else` 문은 `if`문의 마지막 구문이어야 한다.

>       if ([조건]) {   
>           [참 구현부]   
>       } else {   
>           [거짓 구현부]   
>       }

### else if

- `else if` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else if` 문은 앞서 제시된 모든 조건이 거짓일때 부수적인 조건을 추가하여 해당 조건이 참일때 구현부를 실행하기 위해 사용한다.
- `else if` 문은 `if` 문 하나에 여러개 존재할 수 있다.
- `else if` 문은 조건이 비록 참이라 하더라도 선행하는 `if` 혹은 `else if` 의 조건이 참이라면 해당 후행하는 `else if` 는 실행되지 않는다. (하나의 `if` 문에서 실행될 수 있는
  구현부는 하나 이하임으로)
- 모든 `else if` 는 `if` 보다 후행하고 `else` 보다 선행하여야 한다.

>       if ([선행 조건 1]) {   
>           [선행 조건 1 구현부]   
>       } else if ([선행 조건 2]) {   
>           [선행 조건 2 구현부]   
>       } else if ([선행 조건 3]) {   
>           [선행 조건 3 구현부]   
>       } else {   
>           [거짓 구현부]   
>       } 
> - 위 예시에서 `선행 조건 1` 이 참인 경우 `선행 조건 1 구현부` 를 실행하고 나머지 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 이 거짓이고 `선행 조건 2` 가 참인 경우 `선행 조건 2 구현부` 를 실행하고 후행하는 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 및 `선행 조건 2` 가 거짓이고 `선행 조건 3` 이 참인 경우 `선행 조건 3 구현부` 를 실행하고 후행하는 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1`, `선행 조건 2`, `선행 조건 3` 이 모두 거짓이라면 `else`를 실행한다.
> - 즉, `else if` 의 개수와 무관하게 하나의 `if` 문에 존재하는 구현부는 실행되지 않거나, 단 한 개만 실행될 수 있다.

### switch

- `switch` 문은 `분기 대상 변수` 가 가지는 값에 따라 `case` 를 활용하여 실행할 구문을 분리하기 위해 사용한다.

>       switch ([분기 대상 변수]) {   
>           case [값 1]:   
>               [값 1 구현부]   
>               [break;]?   
>           case [값 2]:   
>               [값 2 구현부]   
>               [break;]?  
>           [default:]?   
>               [default 구현부]?   
>       }
> - `분기 대상 변수` 가 가지는 값이 `case` 에 명시된 `값` 과 일치하는 가장빠른 `case` 의 구현부가 실행된다.
> - 일치하는 `case` 가 없다면 `default` 구현부가 실행된다.
> - `break` 키워드는 해당 위치에서 즉시 `switch` 문을 종료하겠다는 의미이다.
> - `default` 는 여러개 존재할 수 없으며 작성시 반드시 `switch` 의 마지막에 위치해야 한다.

- break 키워드가 없으면, 일치하는 케이스 포함한 아래의 모든 코드를 실행한다.

### 배열

- 배열(Array)은 하나의 변수로 동일하거나 호환되는(묵시적 형변환이 가능한) 타입의 값을 여러개 가질수 있도록 하기 위해 사용한다.
- 배열은 비록 이가 가질 인자의 타입이 기초 타입이라 하더라도 메모리의 작동 방식은 참조 타입과 같다. 고로 `null` 값을 가질 수 있다.
- (기초 타입은 `null`일 수 없다. 하지만 참조 타입은 `null`일 수 있다.)
- 변수 선언시 타입에 대괄호(`[]`)를 활용하여 해당 변수가 배열임을 나타낸다.
- 배열의 이름은 주로 복수형으로 짓거나, 접미어로 `Array`를 붙여 짓는 편이다.

>       T[] 이름;
>
>
>   - 가령 정수(`int`) 배열인 `nums`는 아래와 같이 선언한다.
>
>
>       int[] nums;

### 초기화

- 배열의 초기화는 **인자의 나열** 혹은 **배열의 길이 지정**중 하나여야 한다.
- 배열이 초기화된 후에는 다시 초기화하는 방법 외에 배열이 가질 수 있는 인자의 개수를 줄이거나 늘릴 수 없음에 유의한다.
- 배열이 가질 **인자의 나열**은 아래 방식으로 한다.

>       T[] ts = new T[] {, ... };
>
>
>   - 가령, 정수(`int`)배열에 대해 인자로 `1`, `2`, `3`을 가지는 배열의 초기화는 아래와 같이 할 수 있다.
>
>
>       int[] nums = new int[] {1, 2, 3};
>
>
>   - 혹은 아래와 같이 문맥상 그 타입이 명확한 경우 객체화 연산자를 생략할 수 있다.
>
>
>       int[] nums = {1, 2, 3};

- **배열의 길이 지정**은 아래 방식으로 한다.

>       T[] ts = new T[n]
>
>
>   - 가령, 정수(`int`)배열에 대해 길이가 3인 배열의 초기화는 아래와 같이 할 수 있다.
>
>
>       int[] nums = new int[3];
>
>
>   - 길이 지정을 통해 초기화된 배열이 가지는 모든 인자는 기본 값으로 초기화 되며 기본 값은 아래와 같다.
      >

- 정수 및 실수 등 숫자 기초 타입: `0`

>     - 문자 기초 타입: `\0`
>     - 논리 기초 타입: `false`
>     - 모든 참조 타입: `null`

- **인자의 나열**과 **배열의 길이 지정**을 동시에 사용하여서는 안된다.

>       int[] nums = new int[3] {1, 2, 3}; // error
>
>
>   - 위와 같이 동시에 배열의 길이도 지정하고(`3`), 인자도 나열(`{1, 2, 3}`) 하여서는 안 된다.

### 인자

- 배열은 배열이 가지는 각 인자에 대해 인덱스를 가지고 있는데, 이 인덱스는 반드시 `0`부터 시작하여 `1`씩 증가한다.
- 배열이 가지는 인자에 인덱스로 접근하기 위해서는 배열 변수에 대해 대괄호(`[]`)를사용할 수 있다.

>       int[] odds = {1, 3, 5, 7, 9};
>       System.out.println(odds[1]); // 3
>       System.out.println(odds[3]); // 7

- 배열이 가지고 있는 인자의 값을 재할당하고자 할 때 그 인덱스로 접근하여 재할당할 수 있다.

>       int[] odds = {1, 2, 5, 7, 9};
>       System.out.println(odds[1]); // 2
>       odds[1] = 3;
>       System.out.println(odds[1]); // 3

- 배열이 가지고 있는 인자의 개수를 가지고 있는 속성은 `length` 이다.

>       int[] odds = {1, 3, 5, 7, 9};
>       System.out.println(odds.length); // 5
>
>
>   - 인자를 가지는 모든 배열의 `length` 속성 값에서 `1`을 뺀 값은 항상 마지막 인자의 인덱스이다.
>   - 배열이 가지고 있는 인자의 인덱스 범위를 벗어난 인자에 접근할 경우 `ArrayIndexOutOfBoundsException` 예외(`Exception`)가 발생함으로 유의한다.

- 배열이 가지고 있는 메서드 `clone`을 호출하여 동일한 인자를 가지는 배열을 반환받을 수 있다.

>       int[] oddsOriginal = {1, 3, 5, 7, 9};
>       int[] oddsNew = oddsOriginal.clone();

- 배열의 메모리 생태는 참조 타입과 같음으로 비록 그 인자의 구성이 동일하다 하더라도 배열간에 동부등 비교를 하지 않도록 한다.

>       int[] nums1 = {1, 3, 5};
>       int[] nums2 = {1, 3, 5};
>       System.out.println(nums1 == nums2); // false

### 메서드

- 메서드(메소드, Method)는 클래스 혹은 인터페이스 등의 구성요소가 가지는 멤버(Member)중 하나이며, 호출(Call, Invoke) 가능한 동작 단위인 대상이다.
- 메서드 구현부 작성시, 메서드의 이름에 따라 최소한의 역할만 하도록 로직을 작성하는 것이 중요하다.
- 명명법: 카멜 케이스(V, V+O, (be)+Adj)
- 메서드의 구조는 아래와 같다.

>       [접근 제한자] [abstrict|final|static]? [반환 타입|void] [메서드 이름] ([매개 변수, ...]) {
>           [구현부]
>       }
>
>
>   - `abstract`: 해당 매서드가 추상 메서드임을 의미한다.
      >

- 추상 메서드의 `접근 제한자`는 `private`일 수 없다.

>     - 추상 메서드는 정적(`static`)일 수 없다.
>     - 추상 메서드는 구현부를 가지지 않아야 한다.
>     - 추후 해당 메서드를 멤버로 가지는 클래스를 상속 받거나 인터페이스를 구현하는 대상으로 하여금 해당 매서드의 구현부를 직접 구현하도록 하여야 한다.
>     - 추상 메서드를 멤버로 가지는 대상은 추상 클래스 이거나 인터페이스여야 한다.
>   - `final`: 해당 메서드가 최종적임을 알린다.
      >

- 최종적인 메서드는 재정의(Override)할 수 없다.

>     - 최종적인 메서드는 추상적(`abstract`)일 수 없다.
>     - 해당 메서드의 구현부가 절대적이고 앞으로 변하여서는 안 되는 로직을 가지는 경우 이를 최종적으로 만들어 보호한다.
>   - `static`: 해당 매서드가 정적임을 의미한다. 정적인 메서드는 주로 유틸리티성을 가지며, 객체가 아닌 타입의 이름으로 접근할 수 있다.
      >

- 정적인 메서드는 추상적(`abstract`)일 수 없다.

>     - 정적인 메서드는 재정의 대상이 아님으로 최종적(`final`)일 필요가 없다.
>     - 정적인 메서드는 이를 가지고 있는 타입이 객체화되지 않아도 프로그램이 실행될 때 그 존재가 메모리에 등록된다.
>   - `void`: 해당 매서드의 반환값이 없음을 의미한다. 호출 셜과로 어떠한 값도 반환(`return`)할 수 없다. (단, 메서드 종료를 위한 단순 `return`은 사용 가능)
      >

- 반환 타입이 있는 경우 명시적으로 예외를 던지는(`throw`)경우를 제외하고 모든 경우의 수에서 값을 반환(`return`)하여야 한다.

### 매개 변수

- 매개 변수(Parameter)는 매서그가 요구하는 변수 구성이다.
- 해당 매서드를 호출할 때 요구되는 매개 변수에 대해 전달하는겂을 던달 인자(Argument)라고 한다.
- 명명법: 카멜 케이스
- 매개변수의 구조는 아래와 같고 쉼표(`,`)로 구분하여 여러개 작성할 수 있다.

>       [final]? [타입] [이름], ...

#### 가변 인자

- 가변 인자(Variable Argument)는 실질적으로 배열이지만 호출자로 하여금 단순히 쉼표(`,`) 로 구분하여 전달 인자를 쉽게 전달할 수 있게 하기 위해 사용한다.

>       [final]? [타입]... [이름]
>
>
>   - 위와 같이 타입 뒤에 `...`을 붙여 이가 가변 인자임을 지정한다.

- 단, 매개 변수 구조상 가변 인자는 반드시 마지막에 위치하여야 한다.

>       public static int sum(int first, int... nums) {
>
>       }
>
>
>   - 위 구조는 가변 인자 `nums`가 마지막에 매개변수임으로 구조상 문제가 없다.
>
>
>       public static int sum(int first, int... nums, boolean unsafe) {
>   
>       }
>
>
>   - 위 구조는 가변 인자 `nums`가 마지막 매개 변수가 아님으로 올바르지 않은 구조이다.

### String class

- `String`(`java.lang.String) 클래스는 문자열 리터럴이며, 문자열과 관련된 기능을 제공한다.

### 정적 메서드

- `copyValueOf(char[] c)`: 문자 배열 `c`가 가진 문자(`char`)들을 이어 붙인 문자열을 반환한다. `valueOf(char[] c)` 와 같다.
- `format(String s, Object... os)`: 주어진 형식 `s`에 맞도록 하나 이상의 값 `os`를 순차적으로 대입한 문자열을 반환한다. 형식 `s`에는 아래와 같은 표현식을 사용할 수 있다.
    - `%d`: **정수형**(`byte`, `short`, `int`, `long`) 대입
        - `%,d`: 천 자리 단위를 쉼표로 구분하여 대입
        - `%xd`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입
        - `%0xd`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 `0`을 추가하여 대입
        - `%-xd`: 자리수를 `x`자로 맞투어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입
        - `%,xd`, `%0,xd`, `%,-xd` 등의 형태로 조합하여 사용할수 있다. 단, 천 자리 단위를 구분하기 위한 쉼표 또한 자리수(`x`)에 포함된다.
    - `%f`: 실수형(`float`, `double`) 대입
        - `%,f`: 천 자리 단위를 쉼표로 구분하여 대입
        - `%xf`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입. 단, 소수점을 표현하기 위한 **마침표 자리** 또한 자리수(`x`)에 포함된다.
        - `%0xf`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 `0`을 추가하여 대입. 단, 소수점을 표현하기 위한 **마침표 자리** 또한 자리수(`x`)에 포함된다.
        - `%-xf`: 자리수를 `x`자로 맞투어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입. 단, 소수점을 표현하기 위한 **마침표 자리** 또한 자리수(`x`)에 포함된다.
        - `%.nf`: 소수점을 `n`자 까지만 표시하고, 나머지는 반올림하여 대입
        - `%x.nf`, `%0x.nf`, `%-x.nf`, `%,xf`, `%,x.nf`, `%,-x.nf` 등의 형태로 조합하여 사용할수 있다. 단, 천 자리 단위를 구분하기 위한 쉼표 또한 자리수(
          `x`)에 포함된다.
    - `%n`: 개행자 대입(`\n`과 동일), 값을 대입 받지 않는다.
    - `%s`: 문자열(`String`) 대입.
        - `%xs`: 자리수`x` 자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입
        - `%-xs`: 자리수`x` 자로 맞추어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입
        - `%.xs`: 최대로 출력될 수 있는 문자열의 길이를 `n`으로 제한하여 대입
- `join(CharSequence d, CharSequence... C)`: 가변인자 `c`의 인자를 `d`로 이어붙인 문자열을 반환한다.
- `valueOf(char[] c)`: 문자 배열 `c`가 가진 문자(`char`)들을 이어 붙인 문자열을 반환한다. `copyValueOf(char[] c)` 와 같다.
- `valueOf(byte|short|int|long|float|double|boolean|char x)`: 기초 타입의 값 `x`가 가진 내용을 문자열로 반환한다.
- `valueOf(Object o)`: 전달되는 `o`가 가진 `toString()` 메서드의 호출 결과를 반환한다.
- `[타입 이름].[메서드]` (예, String.format();)

### 객체 메서드

- `charAt(int i)`: 호출 대상인 문자열이 가지는 문자 중 `i`번째 문자(`char`)를 반환한다. 인덱스는 `0`번부터 시작함에 유의.
- `concat(String s)`: 호출 대상인 문자열이 가지는 내용 끝에 전달받은 문자열 `s`를 이어 붙인 새로운 문자열을 반환한다. 호출 대상인 문자열과 전달 받은 문자열의 내용에는 변화가 없음에 유의.
- `contains(CharSequence c)`: 호출 대상인 문자열의 내용에 인자 `c`가 포함되어 있는가의 여부를 반환한다.
- `endsWith(String s)`: 호출 대상인 문자열의 내용이 `s`로 끝나는가의 여부를 반환한다.
- `startsWith(String s)`: 호출 대상인 문자열의 내용이 `s`로 시작하는가의 여부를 반환한다.
- `equals(Object o)`: 전달 받은 인자 `o`가 문자열이라면, 호출 대상인 문자열이 가지는 내용과 `o`가 가지는 내용이 같은가의 여부를 반환한다.
- `equalsIgnoreCase(String s)`: `equals`와 동일하나 **대소문자**를 구분하지 않는다.
- `indexOf(String s)`: 호출 대상인 문자열이 가지는 내용 중 `s`와 일치하는 첫번째 인덱스를 반환한다. 일치하는 내용이 없다면 `-1`을 반환한다.
- `lastIndexOf(String s)`: 호출 대상인 문자열이 가지는 내용 중 `s`와 일치하는 마지막 인덱스를 반환한다. 일치하는 내용이 없다면 `-1`을 반환한다.
- `length()`: 호출 대상인 문자열의 길이를 반환한다.
- `matches(String p)`: 호출 대상인 문자열의 내용이 정규표현식 `p`를 만족하는가의 여부를 반환한다.
- `repeat(int n)`: 호출 대상인 문자열의 내용을 `n`번 반복한 새로운 문자열을 반환한다.
- `replace(CharSequence f, CharSequence t)`: 호출 대상인 문자열이 가지고 있는 내용 중 `f`를 찾아 `t`로 치환한 새로운 문자열을 반환한다.
- `replaceAll(String r, String t)`: 호출 대상인 문자열이 가지고 있는 내용 중 정규표현식 `r`을 만족하는 내용을 찾아 `t`로 치환한 새로운 문자열을 반환한다.
- `split(String p)`: 호출 대상인 문자열이 가지는 내용에서 정규표현식 `p`를 기준으로 나눈 문자열 배열을 반환한다.
- `strip()`: 호출 대상인 문자열의 내용에서 선후행 공백을 모두 제거한 새로운 문자열을 반환한다. `trim()`과 같음.
- `stripLeading()`: 호출 대상인 문자열의 내용에서 선행 공백을 모두 제거한 새로운 문자열을 반환한다.
- `stripTrailing()`: 호출 대상인 문자열의 내용에서 후행 공백을 모두 제거한 새로운 문자열을 반환한다.
- `substring(int f, int t)`: 호출 대상인 문자열이 가지는 내용에서 인덱스가 `f` 이상이고 `t` 미만인 문자열을 반환한다. 인덱스는 `0`부터 시작한다.
- `toCharArray()`: 호출 대상인 문자열이 가지는 내용을 문자 배열(`char[]`)로 변환하여 반환한다.
- `toLowerCase()`: 호출 대상인 문자열이 가지는 내용 중 모든 라틴 문자를 소문자화하여 반환한다.
- `toUpperCase()`: 호출 대상인 문자열이 가지는 내용 중 모든 라틴 문자를 대문자화하여 반환한다.
- `[변수 이름].[메서드]` (예, String message = "Hello"; message.length();)

### Integer class

- `Integer`(`java.lang.Integer`) 클래스는 일반 정수(`int`)와 관련된 편의 기능을 제공하고, 해당 타입 자체가 `int` 타입의 리터럴로 작동할 수 있는 일반 정수(`int`)의 래퍼(Wrapper) 클래스이다.

### 정적 멤버 변수

- `MAX_VALUE`: `int` 타입이 가질 수 있는 가장 큰 값
- `MIN_VALUE`: `int` 타입이 가질 수 있는 가장 작은 값

### 정적 메서드

- `parseInt(String s)`: 전달된 문자열 `s`를 일반 정수(`int`)로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 `NumberFormatException` 예외가 발생한다.
- `parseInt(String s, int r)`: 전달된 문자열 `s`를 `r`진법으로 인식하여서 10진법으로 변환한 일반 정수(`int`)를 반환한다.
- `toBinaryString(int i)`: 전달된 일반 정수(`int`) `i`를 2진법의 문자열로 변환하여 반환한다.
- `toHexString(int i)`: 전달된 일반 정수(`int`) `i`를 16진법의 문자열로 변환하여 반환한다.
- `toOctalString(int i)`: 전달된 일반 정수(`int`) `i`를 8진법의 문자열로 변환하여 반환한다.
- `toString(int i)`: 전달된 일반 정수(`int`) `i`를 문자열로 변환하여 반환한다.

### 객체 매서드

- `byteValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `byte` 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음. 
- `shortValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `short` 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- `intValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `int` 반환한다.
- `longValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `long` 타입으로 변환하여 반환한다.
- `floatValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `float` 타입으로 변환하여 반환한다.
- `doubleValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `double` 타입으로 변환하여 반환한다.
- `toString()`: 호출 대상이 가진 일반 정수(`int`)를 문자열로 변환하여 반환한다.
