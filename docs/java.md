### 공통

### 서론

1. 자바(Java)언어는 컴파일시 바이트 코드가 되는 언어로, 개발자가 작성한 코드가 바이트 코드로 컴파일 되어 운영체제 커널(Kernel)이 이를 직접 읽어들이지 않고, JRE(Java Runtime
   Environment)가 해당 바이트코드를 읽어들여 그 결과인 바이너리 코드를 운영체제 커널이 이해할 수 있는 형태로 전달하는 방식을 채택하고 있다.
2. 이러한 방식 때문에, 각 운영체제에 맞는 JRE가 적절하게 구축되어 있다면 하나의 코드로 컴파일된 실행 파일로 운영체제와 무관하게 개발 및 실행할 수 있다는 장점이 있지만, 컴파일 결과가 즉시 바이너리
   코드로 변환되는 언어에 비해 속도가 느리다는 단점이 있다.

### JRE

- JRE(Java Runtime Environment)는 자바로 작성된 프로그램을 실행하기 위해 필요한 구성요소의 집합인 소프트웨어이다.

### JDK

- JDK(Java Development Kit)는 자바 언어로 프로그램을 개발하고 실행하기 위한 구성요소의 집합인 소프트웨어이다. 이는 JRE를 포함하고 있다.

### JVM

- JVM(Java Virtual Machine)는 자바로 개발된 프로그램을 실행하기 위해 구축된 가상의 환경을 의미한다.
- JRE 설치 후 실제로 자바로 작성된 프로그램을 구동하여 바이너리 코드로 변환하는 실행 환경이다.

### 진입점

- 프로그램이 실행되었을 때 가장 먼저 실행될 메서드이다.
- 진입점이되는 메서드는 하나의 프로그램 내에 하나만 있어야 한다.
- 자바에서 진입점은 아래와 같이 작성한다.

>       public static void main(String[] args) {
>           
>       }

### 정적

- 자바에서 정적(`static`)인 리소스는 프로그램이 실행되는 순간, 진입점(`main` 메서드)이 실행되기 전, 모두 선언된다.
- 반대로 비정적인(Non-static)인 리소스는 해당 리소스를 포함하는 구성요소가 객체화될 때 혹은 메서드가 실행될 때 선언된다.
- 정적인 리소스는 메모리 상에서 유일하다(단 하나만 존재). 이를 포함하는 구성 요소가 객체화 되더라도 정적인 대상은 제외된다.
- 따라서, 비정적인 대상이 정적인 대상에 접근하는 것은 항상 허용되지만, 정적인 대상이 비정적인 대상에 (객체화 없이)접근하는 것은 허용되지 않을 수 있다.

>       ▶(run)----------static resource----------main----------|

#### print

- 'sout' + tab >>> System.out.println : print + ln, 개행o
- System.out.print: 개행x

### 타입

- 타입(Type)은 어떠한 값을 담을 수 있는 형태(종류)이다. 크게 기초 타입과 참조 타입으로 나누어져 있다.

### 기초 타입

- 기초 타입(기본 타입, 원시 타입, Primitive Type)은 해당 타입의 변수 값이 리터럴(Literal)이고 메모리의 스택(Stack)영역에 값이 직접 할당되는 타입이다.
- 정수형
    - `byte`: (1 Byte) `-128` 이상 `127` 이하의 수
    - `short`: (2 Bytes) `-32,768` 이상 `32,767` 이하의 수
    - `int`: (4 Bytes) `-2,147,483,648` 이상 `2,147,483,647` 이하의 수
    - `long`: (8 Bytes) `-9,223,372,036,854,775,808` 이상 `9,223,372,036,854,775,807` 이하의 수. 리터럴 숫자 끝에 `L`을 붙임으로써 `long`
      타입의 숫자임을 명시적으로 표현할 수 있다.
    - 보다 작은 타입의 값을 보다 큰 타입에 할당하는 것은 가능하지만, 보다 큰 타입의 값을 보다 작은 타입에 할당하는 것은 허용되지 않는다.
    - 별도의 명시가 없는 정수 표기는 모두 `int` 타입으로 간주한다.
        - 단, `byte` 나 `short` 타입에 할당하기 위한 리터럴 정수는 묵시적으로 강제 형변환을 발생시킨다. 보다 상세한 조건은 아래와 같다.
        - `-128` 이상 `127` 이하의 정수 리터럴을 `byte`타입의 변수에 할당하는 경우
        - `-32,768` 이상 `32,767` 이하의 정수 리터럴을 `short`타입의 변수에 할당하는 경우
    - 강제 형변환을 통해 보다 큰 타입의 값을 보다 작은 타입의 변수에 할당할 경우 오버플로우/언더플로우가 발행할 수 있다.
- 실수형
    - `float`: (4 Bytes) `1.4E-45` 이상 `3.4E+38` 이하의 실수. 리터럴인 숫자 끝에 `F`를 붙임으로써 `float` 타입의 숫자임을 명시적으로 표시할 수 있다.
    - `double`: (8 Bytes) `4.9E-324` 이상 `1.79E+308` 이하의 실수. 리터럴인 숫자 끝에 `D`를 붙임으로써 `double` 타입의 숫자임을 명시적으로 표시할 수 있다.
    - 별도의 명시가 없는 실수 표기는 모두 `double` 타입으로 간주한다.
- 문자형
    - `char`: (2 Bytes) 문자 하나를 담기위해 사용하는 타입이다. 특수 문자 홀따옴표(`'`)를 사용한다. 역슬래쉬(`\`)를 활용하여 특수한 문자를 할당할 수 있다. 가령, 개행자는 `\n`이고,
      공란(빈값)은 `\0`와 같다. 문자형 타입의 값은 비어있을 수 없음(`''`)에 유의한다.
- 논리형
    - `boolean`: (1 Byte) 참(`true`)과 거짓(`false`)을 가진다.

>       [타입] [이름] = [값];
>       int i = 23;
>       long l = 2147483647L;
>       int c = (int) 13L; // 강제형변환
>       float = 3.14F;
>
>
>       char c = 'A'; // '\0', '\n', ... 
>       short s = c; // short: -32768~32767 & char: 0~65535
>       int asc = a; // ascii code table (int <> char)

### 참조 타입

- 참조 타입(레퍼런스 타입, Reference Type)은 해당 타입의 변수 값이 리터럴이지 않고(문자열 `Stritng` 제외), 메모리의 스택(Stack) 영역에는 힙(Heap)의 주소가, 힙 영역에는 실제
  값이 저장된다.
- 기초 타입을 제외한 나머지 모든 타입은 참조 타입이다.
- 참조 타입은 `new` 연산을 통해 객체화(Instantiation)하여 구현하고, 이 값을 객체라고 한다. 이 객체의 메모리 크기는 가변적이다.
- 대표적인 참조 타입으로 문자열(`String`)이 있다. 문자열은 객체화 과정(`new`)을 생략하고 쌍따옴표(`"`)특수기호를 통해 리터럴처럼 사용할 수 있도록 처리되어 있다.

### 변수

- 변수(Variable)는 타입과 이름을 가지고 타입에 부합하는값을할당하여 활용하기 위해 사용한다. 종류는 지역 변수와 멤버 변수, 매개 변수 등으로 나눌 수 있다.
- 메서드 내에서 변수를 선언할때 선언부가 속해있는 스코프 혹은 보다 상위 스코프에서 사용중인 이름을 다시 사용할 수 없다. 이는 매개변수를 포함한다.
- 변수 이름으로 예약된 키워드를 사용할 수 없다. (`for`, `int`, `public` 등)

### 지역 변수

- 지역 변수(Local Variable)는 메서드(Method)안에 존재하는 변수이다.
- 지역 변수에 값이 할당된 적이 없다면, 값 할당을 제외한 모든 접근이 제한된다.
- 명명법: 카멜 케이스
- 선언 방식은 아래와 같다.

>       [타입] [이름];
>
>
>   - 혹은 선언과 동시에 값을 초기화하기 위해 아래와 같이 작성할 수 있다.
>
>
>       [타입] [이름] = [값];

### 멤버 변수

- 멤버 변수(Member Variable)는 클래스나 인터페이스 등의 구성 요소가 직접 가지는 변수이다.
- 상수가 아닌 멤버 변수에 값을 할당한 적이 없다면, 자동으로 기본 값이 할당된다. **중요**
    - 정수 밑 실수 등 숫자 기초 타입: `0`
    - 문자 기초 타입: `\0`
    - 논리 기초 타입: `false`
    - 모든 기초 타입: `null`
- 상수인 멤버 변수의 값은 반드시 직접 할당하거나, 생성자를 통해 초기화하여야 한다.
- 명명법: 카멜 케이스

### 매개 변수

- 매개 변수(Parameter)는 메서드 호출시, 호출자가 전달해주는 인자(Argument)를 전달 받기 위해 사용하는 변수이다.

### 상수

- 명명법: 카멜 케이스
- 읽기 전용 변수는 편의상 상수라고 많이 부르며, `final` 키워드를 통해 변수의(스택) 값이 한번 할당된 이후로 변할 수 없음을 지정한다.
- `final` 키워드를 사용하였다 하더라도, 참조 타입의 객체가 가지는 힙 연역의 내용에 대한 불변성(Immutability)이 보장되는 것은 아님으로 엄밀히 말하면 상수(Constant)라고 말하면 안 되나,
  편의상 상수라고 많이 부른다.
- 정적인 상수(`static final`)이며 리터럴(모든 기초 타입 및 `String`)이거나 그 속성의 불변성을 보장하는 참조 타입인 멤버 변수에 한하여 대문자 스네이크 케이스 명명법을 사용한다.
- 매개변수에도 `final` 키워드 사용 가능하다.
- 선언 방식은 아래와 같다.

>       final [타입] [이름] = [값];
>
>
>   - 지역 변수는 상수로 지정하여도 값 초기화를 반드시 할 필요는 없기 때문에 아래와 같이 선언할 수 있다.
>
>
>       final [타입] [이름];
>
>
>   - 상수인 멤버 변수의 값은 반드시 직접 할당하거나, 생성자를 통해 초기화 하여야 한다.

### 연산자

### 할당 연산자

- 일반 할당(`=`): `x = y` 꼴에서 `x`에 `y`를 대입한다.
- 더하기 복합 대입 연산(`+=`): `x += y` 꼴에서 `x` 와  `y`를 더한 값을 `x`에 재할당한다.
- 빼기 복합 대입 연산(`-=`): `x -= y` 꼴에서 `x` 와 `y`를 뺀 값을 `x`에 재할당한다.
- 곱하기 복합 연산(`*=`): `x *= y` 꼴에서 `x` 와 `y`의 곱을 `x`에 재할당한다.
- 나누기 복합 연산(`/=`): `x /= y` 꼴에서 `x` 를 `y`로 나눈 몫을 `x`에 재할당한다.
- 나머지 복합 연산(`%=`): `x %= y` 꼴에서 `x` 를 `y`로 나눈 나머지를 `x`에 재할당한다.

### 비교 연산자

- 동등(`==`): `x == y` 꼴에서 `x` 와 `y`의 (스택) 값이 같은가의 여부이다.
- 부등(`!=`): `x != y` 꼴에서 `x` 와 `y`의 (스택) 값이 다른가의 여부이다.
- 초과(`>`): `x > y` 꼴에서 `x` 가 `y` 보다 큰가의 여부이다.
- 미만(`<`): `x < y` 꼴에서 `x` 가 `y` 보다 작은가의 여부이다.
- 이상(`>=`): `x >= y` 꼴에서 `x` 가 `y` 보다 크거나 같은가의 여부이다.
- 이하(`<=`): `x <= y` 꼴에서 `x` 가 `y` 보다 작거나 같은가의 여부이다.
- 초과, 미만, 이상, 이하 연산자의 피연산자는 그 두 피연산자의 타입이 같거나, 하나가 다른 하나의 타입으로 묵시적 형변환이 가능한 형태의 논리값(`boolean`)을 제외한 숫자이거나 이를 감싸는 참조 타입(
  `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double` 등)이어야 한다.
- 동등, 부등 연산자의 피연산자는 그 두 피연산자의 타입이 같거나 하나가 다른 하나의 타입으로 묵시적 형변환이 가능한 형태여야 한다.

### 산술 연산자

- 더하기(`+`): `x + y`꼴에서 `x`와 `y`의 합이다.
- 빼기(`-`): `x - y`꼴에서 `x`에서 `y`를 뺀 값이다.
- 곱하기(`*`): `x * y`꼴에서 `x`와 `y`의 곱이다.
- 나누기(`/`): `x / y`꼴에서 `x`를 `y`로 나눈 몫이다.
- 나머지(`%`): `x % y`꼴에서 `x`를 `y`로 나눈 나머지이다.
- 단항 양수(`+`): `+x`꼴에서 변수 `x`의 부호를 강조한다. 연산결과 타입은 `int`
- 단항 음수(`-`): `-x`꼴에서 변수 `x`가 가지는 값의 부호를 반전한다. 연산결과 타입은 `int`
- 증가(`++`)
    - 전위 증가: `++x`꼴에서 구문 실행 전 `x`에 `1`을 더한다.
    - 후위 증가: `x++`꼴에서 구문 실행 후 `x`에 `1`을 더한다.
- 감소(`--`)
    - 전위 감소: `--x`꼴에서 구문 실행 전 `x`에서 `1`을 뺀다.
    - 후위 감소: `x--`꼴에서 구문 실행 후 `x`에서 `1`을 뺀다.
- 숫자 타입(정수, 실수)간의 사칙 연산 결과는, 두 피연산자의 타입이 같다면, 반드시 동일 타입으로 연산된다. (10 / 3 >>> int 3, 100_000 * 100_000 >>> int overflow)
- 숫자 타입간의 사칙 연산 중, 두 피연산자의 타입이 다르다면, 보다 큰 타입으로 연산된다.
- 단, 사칙 연산의 두 피연산자 혹은 일부 산술 연산자의 피연산자의 타입이 `int` 미만의 정수 타입(`byte`, `short`)일 경우 그 연산 결과는 `int`이다.

>       byte a = 5;
>       final byte a0 = 5;
>       byte b = 5;
>       final byte b0 = 5;
>
>       byte c = a + b; // error
>       byte d = a0 + b0; // ok >>> a0, b0 값이 final 때문에 확정적이다.
>       byte e = -a; // error >>>  a가 -128일때(byte -128~127) overflow

### 논리 연산자

- 논리 AND(`&&`): `x && y` 꼴에서 `x`와 `y`가 모두 참(`true`)인가의 여부이다.
- 논리 OR(`||`): `x || y` 꼴에서 `x`와 `y`중 하나가 참(`true`)인가의 여부이다.
- 논리 NOT(`!`): `!` 꼴에서 `x`의 논리를 부정(반전)한다.

### 삼항 연산자

- 삼항 연산자(`? : `): `c ? t : f` 꼴에서 조건 `c`가 참(`true`)이라면 `t`, 거짓(`false`)이라면 `f`가 된다.

### 기타 연산자

- 멤버 접근(`.`): `x.y` 꼴에서 `x`의 멤버인 `y`에 접근하기 위해 사용한다.
- 배열 접근 인자(`[]`): `x[y]` 꼴에서 배열인 `x`의 인자 중 인덱스가 `y`인 인자에 접근하기 위해 사용한다.
- 객체화(`new`): `new T` 꼴에서 타입 `T`를 객체화하기 위해 사용한다.
- 메서드 호출(`()`): `f()` 꼴에서 메서드 `f`를 호출하기 위해 사용한다.
- 우선 연산(`()`): `(x)` 꼴에서 연산 `x`를 우선하기 위해 사용한다.
- 단항 형 변환(`(T)`): `(T) x` 꼴에서 `x`늬 타입을 강제로(명시적으로) `T`로 변환한다.
- 타입 비교(`instanceof`): `x instanceof T` 꼴에서 (기초 타입이 아닌)값 `x`가 (참조) 타입 `T`로 형변환될 수 있는가의 여부이다.

### 연산자 우선순위

1. 우선 연산, 메서드 호출, 배열 인자 접근, 멤버 접근 (`()`, `()`, `[]`, `.`)
2. 후위 증가, 후위 감소 (`++`, `--`)
3. 전위 증가, 전위 감소, 단항 양수, 단항 음수, 논리 NOT (`++`, `--`, `+`, `-`, `!`)
4. 객체화 (`new`)
5. 곱하기, 나누기, 나머지 (`=`, `/`, `%`)
6. 더하기, 빼기 (`+`, `-`)
7. 초과, 미만, 이상, 이하 타입 비교 (`>`, `<`, `>=`, `<=`, `instanceof`)
8. 동등, 부등 (`==`, `!=`)
9. 논리 AND (`&&`)
10. 논리 OR (`||`)
11. 삼항 연산자 (`? :`)
12. 할당, 복합 대입 연산 (`=`, `+=`, `-=`, `*=`, `/=`, `%=`)

### 반복문

### for

- `for` 반복문은 반복의 기준이되는 변수(주로 인덱스)를 활용하여 특정 구혅부를 반복 실행하고자 할 때 사용한다

>       for ([변수 선언 및 초기화]; [반복 조건]; [변수 가감 및 할당]) {
>           [구현부]
>       }
>
>
>       i. `for` 반복문을 위한 `변수 선언 및 초기화`를 실행한다.
>       ii. `반복 조건`이 참(`true`)인지 확인한다.
>           - `반복 조건`이 참(`true`)이라면 `구현부`를 1회 실행하고 `iii`로 이동한다.
>           - `반복 조건`이 거짓(`false`)이라면 `for` 반복문을 실행을 즉시 종료한다.
>       iii. 

### 향상된 for(Enhanced for)

- 향상된 for(Enhanced for) 반복문은 반복할 수 있는 대상이 가지는 인자에 대해 반복하기 위해 사용한다.
- 인덱스가 필요 없을 경우 인덱스 범위 오류를 최소화 및 가독성 향상 등을 위하여 가능한한 향상된 for 반복문을 사용하는 것이 좋다.

>       for ([변수 선언] : [반복 대상]) {
>           [구현부]
>       }

### while

- `while` 반복문은 주어진 조건이 참(`true`)일때 횟수와 관계없이 구현부를 실행하기 위해 사용한다.

>       while ([조건]) {
>           [구현부]
>       }
>
>
>    - 만약 `조건`이 항상 참(`true`)이거나 거짓(`false`)으로 변하는 경우의 수가 없다면, 혹은 `break` 혹은 `return` 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야한다.

### do ...while

- `do ...while` 반복문은 `while` 반복문과 유사하다.

>       do {
>           [구현부]
>       } while ([조건])
>
>
>    - 만약 `조건`이 항상 참(`true`)이거나 거짓(`false`)으로 변하는 경우의 수가 없다면, 혹은 `break` 혹은 `return` 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야한다.

## 조건문

### if

- 주어진 조건이 참일때만 구현부를 실행하기 위해 사용한다.

>       if ([조건]) {   
>           [구현부]   
>       }

### else

- `else` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else` 문은 앞서 제시된 모든 조건이 거짓일때 최종적으로 실행할 구현부를 위해 사용한다.
- `else` 문은 `if`문 하나에 여러개 존재할 수 없다.
- `else` 문은 `if`문의 마지막 구문이어야 한다.

>       if ([조건]) {   
>           [참 구현부]   
>       } else {   
>           [거짓 구현부]   
>       }

### else if

- `else if` 문은 단독으로 사용할 수 없고, `if` 문과 함께 사용하여야 한다.
- `else if` 문은 앞서 제시된 모든 조건이 거짓일때 부수적인 조건을 추가하여 해당 조건이 참일때 구현부를 실행하기 위해 사용한다.
- `else if` 문은 `if` 문 하나에 여러개 존재할 수 있다.
- `else if` 문은 조건이 비록 참이라 하더라도 선행하는 `if` 혹은 `else if` 의 조건이 참이라면 해당 후행하는 `else if` 는 실행되지 않는다. (하나의 `if` 문에서 실행될 수 있는
  구현부는 하나 이하임으로)
- 모든 `else if` 는 `if` 보다 후행하고 `else` 보다 선행하여야 한다.

>       if ([선행 조건 1]) {   
>           [선행 조건 1 구현부]   
>       } else if ([선행 조건 2]) {   
>           [선행 조건 2 구현부]   
>       } else if ([선행 조건 3]) {   
>           [선행 조건 3 구현부]   
>       } else {   
>           [거짓 구현부]   
>       } 
> - 위 예시에서 `선행 조건 1` 이 참인 경우 `선행 조건 1 구현부` 를 실행하고 나머지 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 이 거짓이고 `선행 조건 2` 가 참인 경우 `선행 조건 2 구현부` 를 실행하고 후행하는 `else if` 와 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1` 및 `선행 조건 2` 가 거짓이고 `선행 조건 3` 이 참인 경우 `선행 조건 3 구현부` 를 실행하고 후행하는 `else`는 고려하지 않는다.
> - 위 예시에서 `선행 조건 1`, `선행 조건 2`, `선행 조건 3` 이 모두 거짓이라면 `else`를 실행한다.
> - 즉, `else if` 의 개수와 무관하게 하나의 `if` 문에 존재하는 구현부는 실행되지 않거나, 단 한 개만 실행될 수 있다.

### switch

- `switch` 문은 `분기 대상 변수` 가 가지는 값에 따라 `case` 를 활용하여 실행할 구문을 분리하기 위해 사용한다.

>       switch ([분기 대상 변수]) {   
>           case [값 1]:   
>               [값 1 구현부]   
>               [break;]?   
>           case [값 2]:   
>               [값 2 구현부]   
>               [break;]?  
>           [default:]?   
>               [default 구현부]?   
>       }
> - `분기 대상 변수` 가 가지는 값이 `case` 에 명시된 `값` 과 일치하는 가장빠른 `case` 의 구현부가 실행된다.
> - 일치하는 `case` 가 없다면 `default` 구현부가 실행된다.
> - `break` 키워드는 해당 위치에서 즉시 `switch` 문을 종료하겠다는 의미이다.
> - `default` 는 여러개 존재할 수 없으며 작성시 반드시 `switch` 의 마지막에 위치해야 한다.

- break 키워드가 없으면, 일치하는 케이스 포함한 아래의 모든 코드를 실행한다.

### 배열

- 배열(Array)은 하나의 변수로 동일하거나 호환되는(묵시적 형변환이 가능한) 타입의 값을 여러개 가질수 있도록 하기 위해 사용한다.
- 배열은 비록 이가 가질 인자의 타입이 기초 타입이라 하더라도 메모리의 작동 방식은 참조 타입과 같다. 고로 `null` 값을 가질 수 있다.
- (기초 타입은 `null`일 수 없다. 하지만 참조 타입은 `null`일 수 있다.)
- 변수 선언시 타입에 대괄호(`[]`)를 활용하여 해당 변수가 배열임을 나타낸다.
- 배열의 이름은 주로 복수형으로 짓거나, 접미어로 `Array`를 붙여 짓는 편이다.

>       T[] 이름;
>
>
>   - 가령 정수(`int`) 배열인 `nums`는 아래와 같이 선언한다.
>
>
>       int[] nums;

### 초기화

- 배열의 초기화는 **인자의 나열** 혹은 **배열의 길이 지정**중 하나여야 한다.
- 배열이 초기화된 후에는 다시 초기화하는 방법 외에 배열이 가질 수 있는 인자의 개수를 줄이거나 늘릴 수 없음에 유의한다.
- 배열이 가질 **인자의 나열**은 아래 방식으로 한다.

>       T[] ts = new T[] {, ... };
>
>
>   - 가령, 정수(`int`)배열에 대해 인자로 `1`, `2`, `3`을 가지는 배열의 초기화는 아래와 같이 할 수 있다.
>
>
>       int[] nums = new int[] {1, 2, 3};
>
>
>   - 혹은 아래와 같이 문맥상 그 타입이 명확한 경우 객체화 연산자를 생략할 수 있다.
>
>
>       int[] nums = {1, 2, 3};

- **배열의 길이 지정**은 아래 방식으로 한다.

>       T[] ts = new T[n]
>
>
>   - 가령, 정수(`int`)배열에 대해 길이가 3인 배열의 초기화는 아래와 같이 할 수 있다.
>
>
>       int[] nums = new int[3];
>
>
>   - 길이 지정을 통해 초기화된 배열이 가지는 모든 인자는 기본 값으로 초기화 되며 기본 값은 아래와 같다.
      >

- 정수 및 실수 등 숫자 기초 타입: `0`

>     - 문자 기초 타입: `\0`
>     - 논리 기초 타입: `false`
>     - 모든 참조 타입: `null`

- **인자의 나열**과 **배열의 길이 지정**을 동시에 사용하여서는 안된다.

>       int[] nums = new int[3] {1, 2, 3}; // error
>
>
>   - 위와 같이 동시에 배열의 길이도 지정하고(`3`), 인자도 나열(`{1, 2, 3}`) 하여서는 안 된다.

### 인자

- 배열은 배열이 가지는 각 인자에 대해 인덱스를 가지고 있는데, 이 인덱스는 반드시 `0`부터 시작하여 `1`씩 증가한다.
- 배열이 가지는 인자에 인덱스로 접근하기 위해서는 배열 변수에 대해 대괄호(`[]`)를사용할 수 있다.

>       int[] odds = {1, 3, 5, 7, 9};
>       System.out.println(odds[1]); // 3
>       System.out.println(odds[3]); // 7

- 배열이 가지고 있는 인자의 값을 재할당하고자 할 때 그 인덱스로 접근하여 재할당할 수 있다.

>       int[] odds = {1, 2, 5, 7, 9};
>       System.out.println(odds[1]); // 2
>       odds[1] = 3;
>       System.out.println(odds[1]); // 3

- 배열이 가지고 있는 인자의 개수를 가지고 있는 속성은 `length` 이다.

>       int[] odds = {1, 3, 5, 7, 9};
>       System.out.println(odds.length); // 5
>
>
>   - 인자를 가지는 모든 배열의 `length` 속성 값에서 `1`을 뺀 값은 항상 마지막 인자의 인덱스이다.
>   - 배열이 가지고 있는 인자의 인덱스 범위를 벗어난 인자에 접근할 경우 `ArrayIndexOutOfBoundsException` 예외(`Exception`)가 발생함으로 유의한다.

- 배열이 가지고 있는 메서드 `clone`을 호출하여 동일한 인자를 가지는 배열을 반환받을 수 있다.

>       int[] oddsOriginal = {1, 3, 5, 7, 9};
>       int[] oddsNew = oddsOriginal.clone();

- 배열의 메모리 생태는 참조 타입과 같음으로 비록 그 인자의 구성이 동일하다 하더라도 배열간에 동부등 비교를 하지 않도록 한다.

>       int[] nums1 = {1, 3, 5};
>       int[] nums2 = {1, 3, 5};
>       System.out.println(nums1 == nums2); // false

### 메서드

- 메서드(메소드, Method)는 클래스 혹은 인터페이스 등의 구성요소가 가지는 멤버(Member)중 하나이며, 호출(Call, Invoke) 가능한 동작 단위인 대상이다.
- 메서드 구현부 작성시, 메서드의 이름에 따라 최소한의 역할만 하도록 로직을 작성하는 것이 중요하다.
- 명명법: 카멜 케이스(V, V+O, (be)+Adj)
- 메서드의 구조는 아래와 같다.

>       [접근 제한자] [abstrict|final|static]? [반환 타입|void] [메서드 이름] ([매개 변수, ...]) {
>           [구현부]
>       }
>
>
>   - `abstract`: 해당 매서드가 추상 메서드임을 의미한다.
      >

- 추상 메서드의 `접근 제한자`는 `private`일 수 없다.

>     - 추상 메서드는 정적(`static`)일 수 없다.
>     - 추상 메서드는 구현부를 가지지 않아야 한다.
>     - 추후 해당 메서드를 멤버로 가지는 클래스를 상속 받거나 인터페이스를 구현하는 대상으로 하여금 해당 매서드의 구현부를 직접 구현하도록 하여야 한다.
>     - 추상 메서드를 멤버로 가지는 대상은 추상 클래스 이거나 인터페이스여야 한다.
>   - `final`: 해당 메서드가 최종적임을 알린다.
      >

- 최종적인 메서드는 재정의(Override)할 수 없다.

>     - 최종적인 메서드는 추상적(`abstract`)일 수 없다.
>     - 해당 메서드의 구현부가 절대적이고 앞으로 변하여서는 안 되는 로직을 가지는 경우 이를 최종적으로 만들어 보호한다.
>   - `static`: 해당 매서드가 정적임을 의미한다. 정적인 메서드는 주로 유틸리티성을 가지며, 객체가 아닌 타입의 이름으로 접근할 수 있다.
      >

- 정적인 메서드는 추상적(`abstract`)일 수 없다.

>     - 정적인 메서드는 재정의 대상이 아님으로 최종적(`final`)일 필요가 없다.
>     - 정적인 메서드는 이를 가지고 있는 타입이 객체화되지 않아도 프로그램이 실행될 때 그 존재가 메모리에 등록된다.
>   - `void`: 해당 매서드의 반환값이 없음을 의미한다. 호출 셜과로 어떠한 값도 반환(`return`)할 수 없다. (단, 메서드 종료를 위한 단순 `return`은 사용 가능)
      >

- 반환 타입이 있는 경우 명시적으로 예외를 던지는(`throw`)경우를 제외하고 모든 경우의 수에서 값을 반환(`return`)하여야 한다.

### 매개 변수

- 매개 변수(Parameter)는 매서그가 요구하는 변수 구성이다.
- 해당 매서드를 호출할 때 요구되는 매개 변수에 대해 전달하는겂을 던달 인자(Argument)라고 한다.
- 명명법: 카멜 케이스
- 매개변수의 구조는 아래와 같고 쉼표(`,`)로 구분하여 여러개 작성할 수 있다.

>       [final]? [타입] [이름], ...

#### 가변 인자

- 가변 인자(Variable Argument)는 실질적으로 배열이지만 호출자로 하여금 단순히 쉼표(`,`) 로 구분하여 전달 인자를 쉽게 전달할 수 있게 하기 위해 사용한다.

>       [final]? [타입]... [이름]
>
>
>   - 위와 같이 타입 뒤에 `...`을 붙여 이가 가변 인자임을 지정한다.

- 단, 매개 변수 구조상 가변 인자는 반드시 마지막에 위치하여야 한다.

>       public static int sum(int first, int... nums) {
>
>       }
>
>
>   - 위 구조는 가변 인자 `nums`가 마지막에 매개변수임으로 구조상 문제가 없다.
>
>
>       public static int sum(int first, int... nums, boolean unsafe) {
>   
>       }
>
>
>   - 위 구조는 가변 인자 `nums`가 마지막 매개 변수가 아님으로 올바르지 않은 구조이다.

### String class

- `String`(`java.lang.String) 클래스는 문자열 리터럴이며, 문자열과 관련된 기능을 제공한다.

### 정적 메서드

- `copyValueOf(char[] c)`: 문자 배열 `c`가 가진 문자(`char`)들을 이어 붙인 문자열을 반환한다. `valueOf(char[] c)` 와 같다.
- `format(String s, Object... os)`: 주어진 형식 `s`에 맞도록 하나 이상의 값 `os`를 순차적으로 대입한 문자열을 반환한다. 형식 `s`에는 아래와 같은 표현식을 사용할 수 있다.
    - `%d`: **정수형**(`byte`, `short`, `int`, `long`) 대입
        - `%,d`: 천 자리 단위를 쉼표로 구분하여 대입
        - `%xd`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입
        - `%0xd`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 `0`을 추가하여 대입
        - `%-xd`: 자리수를 `x`자로 맞투어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입
        - `%,xd`, `%0,xd`, `%,-xd` 등의 형태로 조합하여 사용할수 있다. 단, 천 자리 단위를 구분하기 위한 쉼표 또한 자리수(`x`)에 포함된다.
    - `%f`: 실수형(`float`, `double`) 대입
        - `%,f`: 천 자리 단위를 쉼표로 구분하여 대입
        - `%xf`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입. 단, 소수점을 표현하기 위한 **마침표 자리** 또한 자리수(`x`)에 포함된다.
        - `%0xf`: 자리수를 `x`자로 맞추어, 부족한 자리수 만큼 선행하는 `0`을 추가하여 대입. 단, 소수점을 표현하기 위한 **마침표 자리** 또한 자리수(`x`)에 포함된다.
        - `%-xf`: 자리수를 `x`자로 맞투어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입. 단, 소수점을 표현하기 위한 **마침표 자리** 또한 자리수(`x`)에 포함된다.
        - `%.nf`: 소수점을 `n`자 까지만 표시하고, 나머지는 반올림하여 대입
        - `%x.nf`, `%0x.nf`, `%-x.nf`, `%,xf`, `%,x.nf`, `%,-x.nf` 등의 형태로 조합하여 사용할수 있다. 단, 천 자리 단위를 구분하기 위한 쉼표 또한 자리수(
          `x`)에 포함된다.
    - `%n`: 개행자 대입(`\n`과 동일), 값을 대입 받지 않는다.
    - `%s`: 문자열(`String`) 대입.
        - `%xs`: 자리수`x` 자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입
        - `%-xs`: 자리수`x` 자로 맞추어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입
        - `%.xs`: 최대로 출력될 수 있는 문자열의 길이를 `n`으로 제한하여 대입
- `join(CharSequence d, CharSequence... C)`: 가변인자 `c`의 인자를 `d`로 이어붙인 문자열을 반환한다.
- `valueOf(char[] c)`: 문자 배열 `c`가 가진 문자(`char`)들을 이어 붙인 문자열을 반환한다. `copyValueOf(char[] c)` 와 같다.
- `valueOf(byte|short|int|long|float|double|boolean|char x)`: 기초 타입의 값 `x`가 가진 내용을 문자열로 반환한다.
- `valueOf(Object o)`: 전달되는 `o`가 가진 `toString()` 메서드의 호출 결과를 반환한다.
- `[타입 이름].[메서드]` (예, String.format();)

### 객체 메서드

- `charAt(int i)`: 호출 대상인 문자열이 가지는 문자 중 `i`번째 문자(`char`)를 반환한다. 인덱스는 `0`번부터 시작함에 유의.
- `concat(String s)`: 호출 대상인 문자열이 가지는 내용 끝에 전달받은 문자열 `s`를 이어 붙인 새로운 문자열을 반환한다. 호출 대상인 문자열과 전달 받은 문자열의 내용에는 변화가 없음에 유의.
- `contains(CharSequence c)`: 호출 대상인 문자열의 내용에 인자 `c`가 포함되어 있는가의 여부를 반환한다.
- `endsWith(String s)`: 호출 대상인 문자열의 내용이 `s`로 끝나는가의 여부를 반환한다.
- `startsWith(String s)`: 호출 대상인 문자열의 내용이 `s`로 시작하는가의 여부를 반환한다.
- `equals(Object o)`: 전달 받은 인자 `o`가 문자열이라면, 호출 대상인 문자열이 가지는 내용과 `o`가 가지는 내용이 같은가의 여부를 반환한다.
- `equalsIgnoreCase(String s)`: `equals`와 동일하나 **대소문자**를 구분하지 않는다.
- `indexOf(String s)`: 호출 대상인 문자열이 가지는 내용 중 `s`와 일치하는 첫번째 인덱스를 반환한다. 일치하는 내용이 없다면 `-1`을 반환한다.
- `lastIndexOf(String s)`: 호출 대상인 문자열이 가지는 내용 중 `s`와 일치하는 마지막 인덱스를 반환한다. 일치하는 내용이 없다면 `-1`을 반환한다.
- `length()`: 호출 대상인 문자열의 길이를 반환한다.
- `matches(String p)`: 호출 대상인 문자열의 내용이 정규표현식 `p`를 만족하는가의 여부를 반환한다.
- `repeat(int n)`: 호출 대상인 문자열의 내용을 `n`번 반복한 새로운 문자열을 반환한다.
- `replace(CharSequence f, CharSequence t)`: 호출 대상인 문자열이 가지고 있는 내용 중 `f`를 찾아 `t`로 치환한 새로운 문자열을 반환한다.
- `replaceAll(String r, String t)`: 호출 대상인 문자열이 가지고 있는 내용 중 정규표현식 `r`을 만족하는 내용을 찾아 `t`로 치환한 새로운 문자열을 반환한다.
- `split(String p)`: 호출 대상인 문자열이 가지는 내용에서 정규표현식 `p`를 기준으로 나눈 문자열 배열을 반환한다.
- `strip()`: 호출 대상인 문자열의 내용에서 선후행 공백을 모두 제거한 새로운 문자열을 반환한다. `trim()`과 같음.
- `stripLeading()`: 호출 대상인 문자열의 내용에서 선행 공백을 모두 제거한 새로운 문자열을 반환한다.
- `stripTrailing()`: 호출 대상인 문자열의 내용에서 후행 공백을 모두 제거한 새로운 문자열을 반환한다.
- `substring(int f, int t)`: 호출 대상인 문자열이 가지는 내용에서 인덱스가 `f` 이상이고 `t` 미만인 문자열을 반환한다. 인덱스는 `0`부터 시작한다.
- `toCharArray()`: 호출 대상인 문자열이 가지는 내용을 문자 배열(`char[]`)로 변환하여 반환한다.
- `toLowerCase()`: 호출 대상인 문자열이 가지는 내용 중 모든 라틴 문자를 소문자화하여 반환한다.
- `toUpperCase()`: 호출 대상인 문자열이 가지는 내용 중 모든 라틴 문자를 대문자화하여 반환한다.
- `[변수 이름].[메서드]` (예, String message = "Hello"; message.length();)

### Integer class

- `Integer`(`java.lang.Integer`) 클래스는 일반 정수(`int`)와 관련된 편의 기능을 제공하고, 해당 타입 자체가 `int` 타입의 리터럴로 작동할 수 있는 일반 정수(`int`)의 래퍼(Wrapper) 클래스이다.

### 정적 멤버 변수

- `MAX_VALUE`: `int` 타입이 가질 수 있는 가장 큰 값
- `MIN_VALUE`: `int` 타입이 가질 수 있는 가장 작은 값

### 정적 메서드

- `parseInt(String s)`: 전달된 문자열 `s`를 일반 정수(`int`)로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 `NumberFormatException` 예외가 발생한다.
- `parseInt(String s, int r)`: 전달된 문자열 `s`를 `r`진법으로 인식하여서 10진법으로 변환한 일반 정수(`int`)를 반환한다.
- `toBinaryString(int i)`: 전달된 일반 정수(`int`) `i`를 2진법의 문자열로 변환하여 반환한다.
- `toHexString(int i)`: 전달된 일반 정수(`int`) `i`를 16진법의 문자열로 변환하여 반환한다.
- `toOctalString(int i)`: 전달된 일반 정수(`int`) `i`를 8진법의 문자열로 변환하여 반환한다.
- `toString(int i)`: 전달된 일반 정수(`int`) `i`를 문자열로 변환하여 반환한다.

### 객체 매서드

- `byteValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `byte` 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음. 
- `shortValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `short` 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- `intValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `int` 반환한다.
- `longValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `long` 타입으로 변환하여 반환한다.
- `floatValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `float` 타입으로 변환하여 반환한다.
- `doubleValue()`: 호출 대상이 가진 일반 정수(`int`)값을 `double` 타입으로 변환하여 반환한다.
- `toString()`: 호출 대상이 가진 일반 정수(`int`)를 문자열로 변환하여 반환한다.

### Long class

- `Long`(`java.lang.Long`) 클래스는 큰 정수(`long`)와 관련된 편의 기능을 제공하고, 해당 타입 자체가 `long`타입의 리터럴로 작동할 수 있는 큰 정수(`long`)의 래퍼(
  Wrapper) 클래스이다.
- `Long`클래스가 가지는 실질적인 값은 `long`이지만, `Long`은 `long`과 달리 참조타입으로 `null`을 할당받을 수 있다.

### 정적 멤버 변수

- `MAX_VALUE`: `long`타입이 가질 수 있는 가장 큰 값
- `MIN_VALUE`: `long`타입이 가질 수 있는 가장 작은 값

### 정적 메서드(Long.method())

- `parseLong(String s)`: 전달된 문자열 `s`를 큰 정수(`long`)로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 `NumberFormatException` 예외가 발생한다.
- `parsLongt(String s, int r)`: 전달된 문자열 `s`를 `r`진법으로 인식하여서 10진법으로 변환한 큰 정수(`long`)를 반환한다.
- `toBinaryString(long n)`: 전달된 큰 정수(`long`) `n`를 2진법의 문자열로 변환하여 반환한다.
- `toOctalString(long n)`: 전달된 큰 정수(`long`) `n`를 8진법의 문자열로 변환하여 반환한다.
- `toHexString(long n)`: 전달된 큰 정수(`long`) `n`를 16진법의 문자열로 변환하여 반환한다.
- `toString(long n)`: 전달된 큰 정수(`long`) `n`를 문자열로 변환하여 반환한다.

### 객체 메서드(long_name.method())

- `byteValue()`: 호출 대상이 가진 큰 정수(`long`)값을 `byte` 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- `shortValue()`: 호출 대상이 가진 큰 정수(`long`)값을 `short` 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- `intValue()`: 호출 대상이 가진 큰 정수(`long`)값을 `int` 타입으로 변환하여 반환한다.
- `longValue()`: 호출 대상이 가진 큰 정수(`long`)값을 반환한다.
- `floatValue()`: 호출 대상이 가진 큰 정수(`long`)값을 `float` 타입으로 변환하여 반환한다.
- `doubleValue()`: 호출 대상이 가진 큰 정수(`long`)값을 `double` 타입으로 변환하여 반환한다.
- `toString()`: 호출 대상이 가진 큰 정수(`long`)를 문자열로 변환하여 반환한다.

### Double class

- `Double`(`java.lang.Double`) 클래스는 `double`타입과 관련된 편의 기능을 제공하고, 해당 타입 자체가 `double`타입의 리터럴로 작동할 수 있는 `double`의 래퍼(
  Wrapper) 클래스이다.
- `Double` 클래스가 가지는 실질적인 값은 `double`이나, 이는 참조 타입으로 `null`을 할당받을 수 있다.

### 정적 멤버 변수

- `MAX_VALUE`: `double` 타입이 가질 수 있는 가장 큰 값.
- `MIN_VALUE`: `double` 타입이 가질 수 있는 가장 작은 값.
- `NAN`: 숫자가 아닌 값(Not a Number). 내부적으로 `0.0 / 0.0` 연산으로 구현되어 있다.
- `NEGATIVE_INFINITY`: 음의 무한대. 내부적으로 `-1.0 / 0.0` 연산으로 구현되어 있다.
- `POSITIVE_INFINITY`: 양의 무한대. 내부적으로 `1.0 / 0.0` 연산으로 구현되어 있다.

### 정적 메서드(Double.method())

- `isFinite(double d)`: `d`가 유한한가의 여부를 반환한다. 양/음수를 구분하지 않는다.
- `isInfinite(double d)`: `d`가 무한한가의 여부를 반환한다. 양/음수를 구분하지 않는다.
- `isNaN(double d)`: `d`가 `Double.NaN`인가의 여부를 반환한다. 어떠한 값이 `NaN`인가를 검사할때에는 절대로 동/부등(`==`, `!=`)연산을 하지 않는다.
- `parseDouble(String)`: 문자열`s`를 `double`로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 `NumberFormatException`예외가 발생한다.
- `toString(double d)`: `d`를 문자열로 변환하여 반환한다.

### 객체 메서드(double_name.method())

- `byteValue()`: 호출 대상이 가진 `double` 값을 `byte` 타이으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있다.
- `shortValue()`: 호출 대상이 가진 `double` 값을 `byte` 타이으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있다.
- `intValue()`: 호출 대상이 가진 `double` 값을 `byte` 타이으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있다.
- `longValue()`: 호출 대상이 가진 `double` 값을 `byte` 타이으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있다.
- `floatValue()`: 호출 대상이 가진 `double` 값을 `byte` 타이으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있다.
- `doubleValue()`: 호출 대상이 가진 `double` 값을 반환한다.
- `isInfinite()`: 호출 대상이 가진 값이 무한한가의 여부를 반환한다.
- `isNaN()`: 호출 대상이 가진 값이 `NaN`인가의 여부를 반환한다.
- `toString()`: 호출 대상이 가진 값을 문자열로 변환하여 반환한다.

### Math class

- `Math`(`java.lang.Math`)클래스는 수학과 관련된 편의기능을 제공하는 유틸리티 클래스이다.
- 유틸리티 >>> 객체화 하지 않고 사용한다.

### 정적 멤버 변수

- `E`: 자연 상수(e)
- `PI`: 원주율()

### 정적 메서드

- `abs(int|long|float|double x)`: 숫자 `x`의 절댓값을 반환한다.
- `absExact(int|long x)`: 정수 `x`의 절댓값을 반환한다. 단, 오버플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다. (Math.absExact(
  -2147483648))
- `pow(a, b)`: 숫자`a`의 `b`제곱(<code>a<sup>b</sup></code>)을 반환한다.
- `cell(x)`: `x`의 소수부를 올림하여 반환한다.
- `floor(x)`: `x`의 소수부를 내림하여 반환한다.
- `round(x)`: `x`의 소수부를 반올림하여 반환한다.
- `max(int|long|float|double a, int|long|float|double b)`: 숫자 `a`와 `b`중 더 작은 값을 반환한다.
- `min(int|long|float|double a, int|long|float|double b)`: 숫자 `a`와 `b`중 더 작은 값을 반환한다.
- `sqrt(double x)`: 숫자 `x`의 제곱근을 반환한다.
- `cbrt(double x)`: 숫자 `x`의 세제곱근을 반환한다.
- `log(double x)`: 숫자 `x`의 자연 로그를 반환한다.
- `log10(double x)`: 숫자 `x`의 상용 로그를 반환한다.
- `random()`: `0` 이상 `1` 미만의 무작위 실수를 반환한다.
- `addExact(int|long a, int|long b)`: 정수 `a`와 `b`의 합을 반환한다. 단, 오버/언더플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.
- `multiplyExact(int|long a, int|long b)`: 정수 `a`와 `b`의 곱을 반환한다. 단, 오버/언더플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.
- `multiplyFull(int a, int b)`: 일반 정수(`int`) `a`와 `b`의 곱을 큰 정수(`long`)로 반환한다.
- `subtrackExact(int|long a, int|long b`): 정수 `a`와 `b`의 차를 반환한다. 단, 오버/언더플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.
- `negateExact(int|long x)`: 정수 `x`의 부호를 반전하여 반환한다. 단, 오버플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.
- `decrementExact(int|long x)`: 정수 `x`에서 `1`을 뺀 값을 반환한다. 단, 오버플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.
- `incrementExact(int|long x)`: 정수 `x`에 `1`을 더한 값을 반환한다. 단, 오버플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.
- `toIntExact(long x)`: 큰 정수(`long`)인 `x`를 일반 정수(`int`)로 변환하여 반환한다. 단, 오버플로우가 발생할 경우 `ArithmeticException` 예외가 발생한다.

### 예외

- 일반적으로 말하는 에외(`Exception`)는 자바 프로그램이 실행되는 도중 우연의 여부를 가리지 않고 발생할 수 있는 오류를 의미한다. 단, 이러한 "예외"는 `Throwable`의 하위 타입으로, 자바에서
  발생할 수 있는 모든 오류는 사실상 `Throwable`임에 유의한다.

### Throwable

- `Throwable(java.lang.Throwable)`클래스는 '던질 수 있는'이라는 의미로 자바 내에서 발생할 수 있는 일반적인 의미의 '오류'의 최상위 타입이다.
- `try-catch`, `throw` 혹은 메서드의 `throws` 시그니처 대상이 되기 위해서는 직/간접적으로 `Throwable` 타입을 상속 받아야 한다.

#### Error

- `Error`(`java.lang.Error`)클래스는 `Throwable`을 상속 받아 자바 실행 중 발생할 수 있는 기기/환경 요인에 의한 오류를 구현한다.
- 일반적으로 개발자의 실수로 인해 발생하는 문제를 구현하지 않는다. 주로 하드웨어의 메모리 부족이나 가상 환경(JVM)에 치명적인 오류가 있을 때 발생한다.
- 개발자가 직접 `Error`클래스를 살속 받아사용자 정의의 `Error`를 만들거나, 고의로 발생기키는 것은 지양한다.
- `Error`를 상속받는 대표적인 예:
    - `OutOfMemmoryError`: 가상 머신에 할당된 메모리가 부족하여 발생.
    - `StackOverflowError`: 스택 오버플로우로 인하여 발생.
    - `VirtualMachineError`: 가상 환경(JVM)과 관련된 문제로 발생

#### Exception

- `Exception`(`java.lang.Exception`)클래스는 `Throwable`을 상속받아 자바 실행 중 발생할 수 있는 일반적인 오류를 구현한다.
- 예외는 크게 `RuntimeException` 클래스를 직/간접적으로 상속받는 것과, 그렇지 않은 것으로 나누어져 있다.
- 사용자 정의의 오류가 필요하다면, `Exception` 혹은 `RuntimeException`을 상속받아 사용하는 것이 좋다.

#### RuntimeException을 상속받지 않는 것

- **Checked Throwable**로 별도의 명시나 처리 없이 발생시킬 수 없다.
- 대표적인 예:
    - `IOException`
    - `InterruptedException`
    - `TimeOutException`

#### RuntimeException을 상속받는 것

- **Unchecked Throwable**로, 별도의 명시나 처리 없이 발생시킬 수 있다.
- 대표적인 예:
    - `NullPointerException`
    - `ArrayIndexOutOfBoundsException`
    - `ArithmeticException`
    - `NumberFromatException`

### Throwable 발생시키기

- 고의로 `Throwable`을 던지기 위해 `throw` 키워드를 활용한다.

>       throw [Throwable을 상속받는 객체];
>
>
>   - 가령, `NumberFormatException`을 고의로 발생기키기 위해 아래와 같이 작성할 수 있다.
>
>
>       throw new NumberFormatException();

- 발생시키고자 하는 `Throwable`이 **Checked Throwable**이라면, 던지는 구문이 `try-catch`의 `try` 구현부 내에 있거나, 메서드에 `throws` 시그니처에 존재하여야 한다.

### try-catch

- `try-catch`문은 `try`가 가지는 구현부 안에서 발생하는 오류에 대해 오류룰 발생시키지 않고(JVM에 넘기지 않고) `catch`에서 원하는 로직을 실행하기 위해 사용한다.
- `try-catch`문의 구조는 아래와 같다.

>       try {
>           [구현부]
>           [Checked Throwable 가능성 있는 로직]
>       } catch ([처리할 예외 선언: Unchecked Thowable]) {
>           [예외 발생시 실행할 구현부]
>       } catch ([처리할 예외 선언: Checked Thowable]) {
>           [예외 발생시 실행할 구현부]
>       } finally {
>           [최종 구현부]
>       }
>
>   - 하나의 `try`는 여러개의 `catch`를 가질 수 있다.
>   - 여러개의 `catch`를 사용할 때 각 `catch`는 동일한 타입의 예외를 가져서는 안되며, 선행하는 예외가 후행하는 예외보다 부모여서는 안된다.
>   - `catch`하는 예외가 **Checked Throwable**일 경우 해당 예외를 던질 수 있는 가능성이 있는 로직이 `try` 내부에 구현되어 있어야 한다.
>   - `finally`문은 선택 사항이며, 이가 가지는 구현부는 `try`문을 정상 실행(오류 없이) 하였든, 오류가 발생하여 `catch`문으로 빠졌든, 반드시 실행됨을 보장받는다. 모든 `catch`보다
      아래에 있어야 하고, 한 개만 사용할 수 있다.
>   - `catch`나 `finally` 문에서 실행되는 구현부는 이가 포함되어 있는 `try`문에 의해 예외 처리 되지 않음에 유의한다.

### 메서드 예외 시그니처

- 예외를 처리하기 위해 `try-catch`를 사용하지 않고 메서드에 `throws` 시그니처를 사용할 경우 발생하는 예외를 메서드 내부의 로직에서 처리하는 것이 아니라, 해당 메서드의 호출자에게 전가하여 예외헤
  대한 로직을 호출자가 처리하게끔 한다.
- 예외 시그니처가 명시되어있는 메서드를 호출하는 호출자는 명시된 예외에 대한 적절한 처리 없이 해당 메서드를 호출할 수 없다.

>       [메서드 구조] throws [예외, ...] {
>           [구현부]
>       }
>
>
>   - 가령, HTTP 요청을 전송하고 응답을 받아오는 메서드를 작성하기 위해 `HttpClient`타입의 개게가 가진 `client`메서드를 호출하여야 하는데, 해당 메서드는 `IOException`을 던질 수
      있다는 시그니처가 있음으로 아래와 같이 적절한 처리를 해주어야 한다.
>
>
>       try {
>           HttpClient client = HttpClient.newHttpClient();
>           HttpRequest request = HttpClient.newBuilder()
>               .uri(URI.create("https://appi.ifigy.org/?format=json"))
>               .GET()
>               .build();
>           HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
>           System.out.println(resopnse.body);
>       } catch (IOException e) {
>           // IOException 처리 구현부
>           System.out.println("통신 오류가 발생하였습니다.");
>       } catch (InterruptedException e) {
>           // InterruptedException 처리 구현부
>           System.out.println("사용자가 작업을 취소하였습니다.");
>       }

### 클래스

- 클래스(Class)는 서로 관련있는 멤버(멤버 변수 및 메서드 등)의 집합이다.
- 어떠한 구셩요소를 포함하는 `java` 파일은 반드시 접근 제한자가 `public` 이거나 `(defalut)`이고, 그 이름이 파일의 이름과 같은 구성요소를 한 개 포함하여야 한다.
- 명명법: 파스칼 케이스
- 클래스의 구조는 아래와 같다.
- DB table

> ```
>[접근 제한자] [abstarct|final]? class [클래스 이름] [extends 부모 클래스]? [implements 인터페이스, ...]? {
>   [멤버]
>}
> ```
> - `abstract`: 해당 클래스를 추상 클래스로 지정한다. 해당 클래스가 추상 메서드를 한 개 이상 가지려면 반드시 추상 클래스로 지정하여야 한다. 다만, 추상 메서드가 없어도 클래스는 추상적일 수 있다.
> - `final`: 해당 클래스를 최종 클래스로 지정한다. 최종 클래스는 상속 대상(부모)이 될 수 없다.
> - `extends`: 상속 받을 클래스(상속 대상, 부모)를 지정한다.
> - `implements`: 구현할 인터페이스(들)를 지정한다.

### 객체

- 객체(Instance)는 객체화 연산(`new`)을 통해 참조 타입이 객체화된 대상을 의미한다.

### 생성자

- 생성자(Constructor)는 어떠한 타입이 객체화될 때 반드시 호출되는 일종의 특수한 메서드이다.
- 객체화 연산(`new`)시 타입 뒤에 적는 괄호(`()`)는 생성자 호출이다.

> ```
>String str = new String("Hi");
>//                     생성자 호출
> ```

- 생성자의 구조는 아래와 같다.

> ```
>[접근 제한자] [클래스 이름] ([매개 변수, ...]?) {
>   [구현부]
>}
> ```
> - 생성자의 이름은 반드시 클래스의 이름과 일치해야한다.
> - 생성자는 반환 타입을 가지지 않는다. (`void` 또한 명시하지 않는다.)
> - 생성자는 추상적(`abstract`)이거나 최종적(`final`)이거나, 정적(`static`)일 수 없다.
> - 객체화 연산 외에는 임의로 호출할 수 없다.
> - 생성자 구현부의 첫 구문은 반드시 부모 클래스의 생성자 호출(`super(...)`)이거나 자신 클래스의 생성자 호출(`this(...)`)이어야 한다. 이를 생략할 경우 첫 구문은 인자를 전달하지 않는 부모
    생성자 호출(`super()`)인 것으로 한다.
> - 생성자가 가지고 있는 로직이 모두 실행되었을 때 객체화를 완료하였다고 한다.

### 기본 생성자

- 모든 클래스는 생성자를 반드시 가지며 별도의 생성자를 명시하지 않을 경우 기본 생성자가 생략된 상태로 존재한다.
- 기본 생성자의 구조는 아래와 같다.

> ```
> public [클래스 이름]() {
>    super();
> }
> ```

- 단, 사용자가 직접 생성자를 명시할 경우 기본 생성자는 없어짐으로 유의한다.

### 상속

- 상속(Inheritance)은 어떠한 클래스가 다른 클래스로 하여금 다른 클래스의 기능을 그대로 물려받아 추가적인 기능을 확장시키기 위해 사용한다.
- 어떠한 클래스에게 상속 받을 클래스를 명시하지 않을 경우 모든 클래스는 자동으로 `Object`(`java.lang.Object`)클래스를 상속 받는다.
- 상속 받을 클래스를 명시하는 것이 보다 상위 계층의 상속 클래스에 대한 기능 확장을 상실하는 것을 의미하지 않는다.
- 다중 상속 관계는 허용되지 않으며 한 개의 클래스를 상속 받아야 한다.
- 순환 상속 구조를 가질 수 없다. (어느 한 클래스는 Object 클래스를 상속 받아야 한다.)

### 패키지

- 패키지(Package)는 동일한 이름을 가지는 클래스(등의 구성요소)가 동일한 프로젝트에 존재 할 수 없는 문제를 해결하기 위해 존재하는 디렉토리이다.
- 주로 구성요소를 종류별, 목적별로 구분하여 위치시키기 위해 사용한다.
- 루트 패키지(Root Package)의 경로는 주로 `[소유하고 있는 도메인의 역순].[아티팩트 ID]` 형식으로 구성된다.
- 명명법: 전체 소문자, 단어 구분하지 안음

### 접근 제한자

- 접근 제한자(Access Modifier)는 특정 멤버에 접근할 수 있는 대상을 제한하기 위해 사용한다.
- `public`: 제한 없음
- `protected`: 동일한 패키지 경로에 있거나, 상속 관계에 있는 대상만 접근 가능.
- `(default)`: 동일한 패키지 경로에 있는 대상만 접근 가능.
- `private`: 동일한 클래스 내에서만 접근 가능.

### 캡슐화

- 캡술화(Encapsulation)는 주로 엔티티(Entity)클래스, 값 객체(VO, Value Object), 데이터 전달 객체(DTO, Data Transfer Object)등이 가지는 멤버 변수의 외부
  접근을 차단하고, 필요에 따라 핻당 멤버변수를 반환해주기 위한 게터(Getter) 및 새로운 값을 할당하고 해당 값에 대한 논리를 작성하기 위한 세터(Setter) 메서드를 별도로 구현하는 방법을 의미한다.
- 추가적으로 엔티티 클래스 작성시, 대상이 되는 테이블의 기본 키 (Primary Key)인 열(들)에 대해 `equals`및 `hashcode`메서드를 재정의 한다.
- 필요에 따라 아무런 인자도 전달 받지 않는 생성자(No Argument Constructor)와, 모든 멤버 변수(All Arguments Constructor)에 대응하는 전달 인자를 전달 받는 생성자를
  생성하여 활용하기도 한다.

### 다형성

- 다형성(Polymorphism)은 어떠한 타입을 가지는 객체가 다른 타입으로 변할 수 있는 성질을 의미한다.
- 어떠한 객체가 다른 타입으로 형변환될 경우 원래 해당 객체가 가지고 있는 멤버에 대한 접근(일시적으로)제한되고, 변환된 타입의 멤버까지만 접근할 수 있게 된다.
- 클래스간의 상속 관계
    - **자식 객체**는 **부모 타입**에 묵시적 형변환을 통해 할당될 수 <span style="color: green">있다</span>.
    - **부모 객체**는 **자식 타입**에 묵시적 형변환을 통해 할당될 수 <span style="color: red">없다</span>.
    - `객체 instanceof 클래스`를 통해 확인후 강제형변환 할 수 있다.
- 클래스와 인터페이스의 구현 관계
    - 특정 인터페이스를 구현하는 클래스 객체는 인터페이스 타입에 할당될 수 있다.

### 인터페이스

- 인터페이스(Interface)는 특정(직렬)계통에 공통적으로 적용되는 사항이 아닌, 특정 클래스에 대한 **속성**이나 부분적으로 **특화**되어있는 기능의 집합에 대한 틀을 제공하기 위해 사용한다.
- 명명법: 파스칼 케이스
- 인터페이스의 구조는 아래와 같다.

> ```
>[접근 제한자] interface [인터페이스 이름] [extends 상속 인터페이스, ...] {
>   [멤버]
>}
> ```
>
> - 인터페이스는 여러개의 인터페이스를 상속 받을 수 있지만, 클래스를 상속받을 수는 없다.
> - 인터페이스가 가지는 모든 멤버의 접근 제한자는 기본적으로 `public`이다.
> - 인터페이스가 가지는 모든 메서드는 기본적으로 추상적(`abstract`)이다.
> - 단, 인터페이스가 가지는 메서드의 접근 제한자가 `private`일 경우, 그 메서드는 추상적이지 않아야 하며 구현부를 가져야 한다.
> - 인터페이스가 가지는 모든 멤버 변수는 정적이고 읽기 전용(`static final`)이다.
> - 단, 메서드의 반환 타입 앞에 `default` 라는 키워드를 추가하여 해당 메서드가 기본 동작방식을 가진다고 정의하고, 구현부를 정의할 수 있다. 이때 `default`는 접근 제한자와 상관이 없음에
    유의한다.

### 오버로딩

- 오버오딩(Overloading)은 메서드의 이름을 같게 하되, 매개변수의 구조를 다르게 가지는 메서드를 여러개 만드는 것을 의미한다.
- 매개 변수의 개수가 다르거나 타입이 달라야 한다.
- 동일한 타입에 대해 순서만 다른 메서드는 여러개 정의할 수 없다.

### 오버라이드

- 오버라이드(재정의, Override)는 상속 관계에 있는 부모 클래스가 가지고 있는 메서드나 해당 클래스가 구현하고 있는 인터페이스의 메서드의 구현부를 다시 작성하는 것을 의미한다.
- 재정의 대상인 메서드와 이름이 같아야하고 `@Override` 이노테이션을 부여한다.
- 재정의된 메서드를 포함하는 타입을 객체화할 경우 해당 객체가 그 부모 타입(혹은 인터페이스 타입)에 할당되더라도 재정의된 로직이 실행됨에 유의한다.
    - Parent obj = new Child(); >> 자식 객체(class Child extends Parent)가 오버라이드 한 메서드는 그대로 사용 가능. 부모에 없는 메서드는 사용 불가.
- 재정의 대상인 메서드와 매개 변수 구조(개수, 타입과 순서)가 같아야한다.
- 재정의 대상인 매서드와 반환 타입이 같거나, 공변 반환 타입(Covariant Return Type 보다 하위 타입)이어야 한다.
    - Parent.method() return Object & Child.method() return String >> String extends Object 때문에 가능(o)
- 재정의 대상인 메서드가 가지는 접근 제한자와 같거나 넓어야 한다.
- 재정의 대상인 메서드가 가지는 예외 시그니처에 대해 같거나 공변 반환 타입이어야 한다.
- 재정의하고자 하는 메서드가 최종적(`final`)일 경우 재정의할 수 없다.
    - 마찬가지로 final class는 상속할 수 없다.
- '생성 메뉴'(Alt + Insert, Cmd + N)의 `Override Methods...`롤 통해 만들수 있다.

### 열거형

- 열거형(Enumeration)은 어떠한 타입이 가질 수 잇는 값의 개수나 종류가 능동적으로 늘거나 줄지 않고 고정적일 것으로 판단될 때 분류의 목적으로 사용한다.
- 열거형의 명명법: 파스칼 케이스
- 여거형이 가지는 인자의 명명법: 대문자 스네이크 케이스
- 모든 열거형 `T`가 가지는 인자는 `Enum<T>`타입을 상속 받는다. 따라서, 열거형으로 하여금 별도의 클래스를 상속(`extends`)받도록 할 수 없다. 단, 인터페이스를 구형하게 할 수는 있음.
- 열거형의 구조는 아래와 같다.

> ```
>[접근 제한자] enum [열거형 이름] [implements [구현할 인터페이스, ...]]? {
>   [인자 나열]
>   [; 인자 멤버]?
>}
> ```
>
> - 개발자간에 소통의 문제나, 오탈자 등에 의한 인적 오류를 철저히 예방할 수 있음으로 상황이 맞다면 사용이 강력하게 권장된다.
> - 열거형이 가지는 모든 인자는 정적인 읽기 전용(`static final`)이기 때문에 동등(`==`) 및 부등(`!=`) 연산을 사용여도 된다.

# 자료구조

## Collection

- `Collection<E>`(`java.util.Collection<E>`) 인터페이스는 인자의 나열을 가지는 자료구조를 위한 구조체이다.
- 객체 메서드
    - `add(E e)`: 호출 대상의 인자로 `e`를 추가한다.
    - `addAll(Collection<? extends E> c)`: 호출 대상의 인자로 `c`가 가지고 있는 모든 인자를 추가한다.
    - `clear()`: 호출 대상이 가지고 있는 모든 인자를 제거한다.
    - `contains(Object o)`: 호출 대상이 가지고 있는 인자들 중 전달받은 객체 `o`에 대해 동등(`==`)하거나 `equals(...)` 메서드의 호출 결과가 참(`true`)인 인자가 있는가의 여부를 반환한다.
    - `containsAll(Collection<?> c)`: 호출 대상이 전달 받은 `c`가 가지는 모든 인자에 대해 동등(`==`)하거나 `equals(...)` 메서드의 호출 결과가 참(`true`)인 인자들을 모두 가지고 있는가의 여부를 반환한다.
    - `remove(Object o)`: 호출 대상이 가지고 있는 인자들 중 전달 받은 객체 `o`에 대해 동등(`==`)하거나 `equals(...)` 메서드의 호출 결과가 참(`true`)인 인자가 있다면 제거하고 `true`를 반환한다. 그러한 인자가 없다면 `false`를 반환한다.
    - `size()`: 호출 대상이 가지고 있는 인자의 개수를 반환한다.

### List

- `List<E>`(`java.util.List<E>`) 인터페이스는 `Collection<E>` 인터페이스를 상속 받고, <b style="color: green;">순서가 있는</b> 인자의 나열을 가지는 자료구조를 위한 구조체이다.
- 객체 메서드
    - `Collection`이 가지는 모든 객체 메서드
    - `add(int i, E e)`: 호출 대상의 인자로 `e`를 추가한다. 단, 추가하는 인자의 인덱스가 `i`가 되도록 한다. 기존에 인덱스가 `i`였던 인자 및 후행하는 인자의 모든 인덱스는 `1`씩 뒤로 밀린다.
    - `get(int i)`: 호출 대상이 가지고 있는 인자 중 그 인덱스가 `i`인 인자를 반환한다.
    - `indexOf(Object o)`: 호출 대상이 가지고 있는 인자 중 `o`에 대해 동등(`==`)하거나 `equals(...)` 메서드 호출 결과가 참(`true`)인 첫번째 인자의 인덱스를 반환한다. 그러한 인자가 없다면 `-1`을 반환한다.
    - `lastIndexOf(Object o)`: 호출 대상이 가지고 있는 인자 중 `o`에 대해 동등(`==`)하거나 `equals(...)` 메서드 호출 결과가 참(`true`)인 마지막 인자의 인덱스를 반환한다. 그러한 인자가 없다면 `-1`을 반환한다.
    - `remove(int i)`: 호출 대상이 가지고 있는 인자 중 인덱스가 `i`인 인자를 제거한다. 후행하는 인자의 인덱스는 모두 `1`씩 당겨진다.
    - `set(int i, E e)`: 호출 대상이 가지고 있는 인자 중 인덱스가 `i`인 인자의 값을 `e`로 재할당한다.

#### ArrayList

- `ArrayList<E>`(`java.util.ArrayList<E>`) 클래스는 `List<E>` 인터페이스를 구현하는 자료구조 구현체이다.
- 각 인자를 일반 배열처럼 관리하기 때문에, 제공된 인덱스에 따른 인자 접근 속도는 빠르지만, 인자 제거 및 추가 등 인자의 개수가 변하는 경우 속도가 느리다.
- 인자의 추가 및 제거보다 조회 및 재할당이 더 빈번할 경우 사용이 권장된다.
- 객체 메서드
    - `List<E>`가 가지는 모든 객체 메서드

#### LinkedList

- `LinkedList<E>`(`java.util.LinkedList<E>`) 클래스는 `List<E>` 인터페이스를 구현하는 자료구조 구현체이다.
- 각 인자의 존재를 인접한 인자로 하여금 기억하게 함으로써(노드) 각 인자를 관리한다. 그렇기 때문에, 제공된 인덱스에 따른 인자 접근은 느리지만, 인자 제거 및 추가 등 인자의 개수가 변하는 경우 속도가 빠르다.
- 인자의 조회 및 재할당보다 인자의 추가 및 제거가 더 빈번할 경우 사용이 권장된다.
- 객체 메서드
    - `List<E>`가 가지는 모든 객체 메서드

#### Vector

- `Vector<E>`(`java.util.Vector<E>`) 클래스는 `List<E>` 인터페이스를 구현하는 자료구조 구현체이다.
- 역할과 내부 작동 방식은 `ArrayList<E>`와 동일하나, 이가 가진 메서드가 동기화(`synchronized`)되어 있다는 차이가 있다.
- 객체 메서드
    - `List<E>`가 가지는 모든 객체 메서드

#### Stack

- `Stack<E>`(`java.util.Stack<E>`) 클래스는 `Vector<E>` 클래스를 상속 받는 자료구조 구현체이다.
- 후입선출(LIFO, Last In First Out 혹은 FILO, First In Last Out) 방식으로 인자를 관리한다.
- 객체 메서드
    - `Vector<E>`가 가지는 모든 메서드
    - `push(E e)`: 호출 대상의 가장 위에 인자 `e`를 추가한다.
    - `pop()`: 호출 대상이 가지고 있는 인자 중 가장 위에 있는 인자를 제거하고 반환한다.
    - `peek()`: 호출 대상이 가지고 있는 인자 중 가장 위에 있는 인자를 반환한다.

### Set

- `Set<E>`(`java.util.Set<E>`) 인터페이스는 `Collection<E>` 인터페이스를 상속 받고, <b style="color: red;">순서가 없는</b> 인자의 나열을 가지는 자료구조를 위한 구조체이다.
- 객체 메서드
    - `Collection<E>`가 가지는 모든 객체 메서드
    - `iterator()`: `Set` 객체가 가진 인자를 반복할 수 있는 반복자(`Iterator<E>`) 객체를 반환한다.

#### HashSet

- `HashSet<E>`(`java.util.HashSet<E>`) 클래스는 `Set<E>` 인터페이스를 구현하는 자료구조 구현체이다.
- 인자에 순서가 없고, 인자인 객체의 해쉬 값(`hashCode()` 호출 반환값)을 기준으로 동일 여부를 판단하여 보관한다.
- 해쉬 값(`hashCode()`)이 중복되는 인자를 여러개 보관하지 않는다.
- 객체 메서드
    - `Set<E>`가 가지는 모든 객체 메서드

#### SortedSet

- `SortedSet<E>`(`java.util.SortedSet<E>`) 인터페이스는 `Set<E>` 인터페이스를 상속받는 인자 정렬을 위한 자료구조 구조체이다.
- 객체 메서드
    - `Set<E>`가 가지는 모든 객체 메서드

##### TreeSet

- `TreeSet<E>`(`java.util.TreeSet<E>`) 클래스는 `SortedSet<E>` 인터페이스를 구현하는 자료구조 구현체이다.
- 인자를 정렬함에 있어 이진 탐색 트리(Binary Search Tree) 구조를 활용하여, 인자 검색과 정렬이 빠르다.
- 객체 메서드
    - `SortedSet<E>`가 가지는 모든 객체 메서드

## Map

- `Map<K, V>`(`java.util.Map<K, V>`) 인터페이스는 키(`K`)와 값(`V`)으로 이루어진 쌍(Pair, Entity)들의 집합을 가지는 자료구조 구조체이다.
- 이가 가지는 쌍들에는 순서가 없음으로 유의한다.
- 객체 메서드
    - `clear()`: 호출 대상이 가지고 있는 상을 모두 제거한다.
    - `containsKey(K k)`: 호출 대상이 가지고 있는 쌍 중 키가 전달된 `k`와 같은 쌍이 있는가의 여부를 반환한다.
    - `containsValue(V v)`: 호추 대상이 가지고 있는 쌍 중 값이 전달된 `v`와 같은 쌍이 있는가의 여부를 반환한다.
    - `entrySet()`: 호출 대상이 가지고 있는 쌍들에 대한 `Set<Map.Entry<K, V>>`를 반환한다. 여기서 `Map.Entry<K, V>`는 쌍 하나를 의미하며, 아래 객체 메서드를 가진다.
        - `getKey()`: 키를 반환한다.
        - `getValue()`: 값을 반환한다.
        - `setValue(V v)`: 값을 `v`로 지정한다.
    - `get(K k)`: 호출 대상이 가지고 있는 쌍 중 키가 전달된 `k`와 같은 쌍의 값을 반환한다. 그러한 쌍이 없다면 `null`을 반환한다.
    - `getOrDefault(K k, V d)`: 호출 대상이 가지고 있는 쌍 중 키가 전달된 `k`와 같은 쌍의 값을 반환한다. 그러한 상이 없다면 `d`를 반환한다.
    - `keySet()`: 호출 대상이 가지고 있는 쌍들의 키를 인자로 가지는 `Set<K>`를 반환한다.
    - `values()`: 호출 대상이 가지고 있는 쌍들의 값을 인자로 가지는 `Collection<V>`를 반환한다.
    - `put(K k, V v)`: 호출 대상이 가지고 있는 쌍 중 키가 `k`와 동일한 쌍이 없다면, 키로 `k`를 값으로 `v`를 가지는 쌍을 추가한다. 만약 이미 키가 `k`와 동일한 쌍이 있다면, 해당 쌍의 값만 `v`로 대치한다.
    - `putIfAbsent(K k, V v)`: 호출 대상이 가지고 있는 쌍 중 키가 `k`와 동일한 쌍이 없다면, 키로 `k`를 값으로 `v`를 가지는 쌍을 추가한다. 만약 이미 키가 `k`와 동일한 쌍이 있다면, 아무런 동작도 하지 않는다.
    - `replace(K k, V v)`: 호출 대상이 가지고 있는 쌍 중 키가 `k`와 동일한 쌍이 있다면 해당 쌍의 `v`로 대치한다. 만약 키가 `k`와 동일한 쌍이 없다면, 아무런 동작도 하지 않는다.
    - `remove(K k)`: 호출 대상이 가지고 있는 쌍 중 키가 `k`와 같은 쌍을 제거한다.
    - `size()`: 호출 대상이 가지고 있는 쌍의 개수를 반환한다.

### HashMap

- `HashMap<K, V>`(`java.util.HashMap<K, V>`) 클래스는 `Map<K, V>` 인터페이스를 구현하는 자료구조 구현체이다.
- 해당 자료구조에 추가하는 쌍의 순서는 보장되지 않는다.
- 객체 메서드
    - `Map<K, V>`가 가지는 모든 객체 메서드

#### LinkedHashMap

- `LinkedHashMap<K, V>`(`java.util.LinkedHashMap<K, V>`) 클래스는 `HashMap<K, V>` 클래스를 상속받고 `Map<K, V>` 인터페이스를 구현하는 자료구조 구현체이다.
- `HashMap` 자료구조가 쌍의 순서를 보장하지 않음에 비해, `LinkedHashMap`은 이가 가지는 쌍의 키가 이의 위치를 각 키로 하여금 기억하도록 하여, 쌍의 순서를 보장받는다는 차이가 있다.
- 객체 메서드
    - `HashMap<K, V>`가 가지는 모든 객체 메서드

### Hashtable

- `Hashtable<K, V>`(`java.util.Hashtable<K, V>`) 클래스는 `Map<K, V>` 인터페이스를 구현하는 자료구조 구현체이다.
- 역할과 작동 방식은 `HashMap<K, V>`과 동일하나, 메서드가 동기화(Synchronized)되어 있다는 차이가 있다.
- 객체 메서드
    - `Map<K, V>`가 가지는 모든 객체 메서드

### SortedMap

- `SortedMap<K, V>`(`java.util.SortedMap<K, V>`) 인터페이스는 `Map<K, V>` 인터페이스를 상속 받는 쌍을 키로 정렬하기 위한 자료구조 구조체이다.
- 쌍을 정렬하기 위한 인터페이스임으로, `SortedMap` 인터페이스를 상속 받는 인터페이스 혹은 구현하는 클래스인 자료구조는 키에 따라 쌍의 순서를 보장받는다.
- 객체 메서드
    - `Map<K, V>`가 가지는 모든 객체 메서드

#### TreeMap

- `TreeMap<K, V>`(`java.util.TreeMap<K, V>`) 클래스는 `SortedMap<K, V>` 인터페이스를 구현하는 자료구조 구현체이다.
- 쌍을 정렬함에 있어 키에 대해 이진 탐색 트리(Binary Search Tree) 구조를 활용하여, 검색과 정렬이 빠르다.
- 객체 메서드
    - `SortedMap<K, V>`가 가지는 모든 객체 메서드
